/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var GloryGameEngine;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://GloryGameEngine/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/path/path.js":
/*!***********************************!*\
  !*** ./node_modules/path/path.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the\r\n// \"Software\"), to deal in the Software without restriction, including\r\n// without limitation the rights to use, copy, modify, merge, publish,\r\n// distribute, sublicense, and/or sell copies of the Software, and to permit\r\n// persons to whom the Software is furnished to do so, subject to the\r\n// following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\r\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\r\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n\r\nvar isWindows = process.platform === 'win32';\r\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\r\n\r\n\r\n// resolves . and .. elements in a path array with directory names there\r\n// must be no slashes or device names (c:\\) in the array\r\n// (so also no leading and trailing slashes - it does not distinguish\r\n// relative and absolute paths)\r\nfunction normalizeArray(parts, allowAboveRoot) {\r\n  var res = [];\r\n  for (var i = 0; i < parts.length; i++) {\r\n    var p = parts[i];\r\n\r\n    // ignore empty parts\r\n    if (!p || p === '.')\r\n      continue;\r\n\r\n    if (p === '..') {\r\n      if (res.length && res[res.length - 1] !== '..') {\r\n        res.pop();\r\n      } else if (allowAboveRoot) {\r\n        res.push('..');\r\n      }\r\n    } else {\r\n      res.push(p);\r\n    }\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// returns an array with empty elements removed from either end of the input\r\n// array or the original array if no elements need to be removed\r\nfunction trimArray(arr) {\r\n  var lastIndex = arr.length - 1;\r\n  var start = 0;\r\n  for (; start <= lastIndex; start++) {\r\n    if (arr[start])\r\n      break;\r\n  }\r\n\r\n  var end = lastIndex;\r\n  for (; end >= 0; end--) {\r\n    if (arr[end])\r\n      break;\r\n  }\r\n\r\n  if (start === 0 && end === lastIndex)\r\n    return arr;\r\n  if (start > end)\r\n    return [];\r\n  return arr.slice(start, end + 1);\r\n}\r\n\r\n// Regex to split a windows path into three parts: [*, device, slash,\r\n// tail] windows-only\r\nvar splitDeviceRe =\r\n    /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\r\n\r\n// Regex to split the tail part of the above into [*, dir, basename, ext]\r\nvar splitTailRe =\r\n    /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\r\n\r\nvar win32 = {};\r\n\r\n// Function to split a filename into [root, dir, basename, ext]\r\nfunction win32SplitPath(filename) {\r\n  // Separate device+slash from tail\r\n  var result = splitDeviceRe.exec(filename),\r\n      device = (result[1] || '') + (result[2] || ''),\r\n      tail = result[3] || '';\r\n  // Split the tail into dir, basename and extension\r\n  var result2 = splitTailRe.exec(tail),\r\n      dir = result2[1],\r\n      basename = result2[2],\r\n      ext = result2[3];\r\n  return [device, dir, basename, ext];\r\n}\r\n\r\nfunction win32StatPath(path) {\r\n  var result = splitDeviceRe.exec(path),\r\n      device = result[1] || '',\r\n      isUnc = !!device && device[1] !== ':';\r\n  return {\r\n    device: device,\r\n    isUnc: isUnc,\r\n    isAbsolute: isUnc || !!result[2], // UNC paths are always absolute\r\n    tail: result[3]\r\n  };\r\n}\r\n\r\nfunction normalizeUNCRoot(device) {\r\n  return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\r\n}\r\n\r\n// path.resolve([from ...], to)\r\nwin32.resolve = function() {\r\n  var resolvedDevice = '',\r\n      resolvedTail = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1; i--) {\r\n    var path;\r\n    if (i >= 0) {\r\n      path = arguments[i];\r\n    } else if (!resolvedDevice) {\r\n      path = process.cwd();\r\n    } else {\r\n      // Windows has the concept of drive-specific current working\r\n      // directories. If we've resolved a drive letter but not yet an\r\n      // absolute path, get cwd for that drive. We're sure the device is not\r\n      // an unc path at this points, because unc paths are always absolute.\r\n      path = process.env['=' + resolvedDevice];\r\n      // Verify that a drive-local cwd was found and that it actually points\r\n      // to our drive. If not, default to the drive's root.\r\n      if (!path || path.substr(0, 3).toLowerCase() !==\r\n          resolvedDevice.toLowerCase() + '\\\\') {\r\n        path = resolvedDevice + '\\\\';\r\n      }\r\n    }\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    var result = win32StatPath(path),\r\n        device = result.device,\r\n        isUnc = result.isUnc,\r\n        isAbsolute = result.isAbsolute,\r\n        tail = result.tail;\r\n\r\n    if (device &&\r\n        resolvedDevice &&\r\n        device.toLowerCase() !== resolvedDevice.toLowerCase()) {\r\n      // This path points to another device so it is not applicable\r\n      continue;\r\n    }\r\n\r\n    if (!resolvedDevice) {\r\n      resolvedDevice = device;\r\n    }\r\n    if (!resolvedAbsolute) {\r\n      resolvedTail = tail + '\\\\' + resolvedTail;\r\n      resolvedAbsolute = isAbsolute;\r\n    }\r\n\r\n    if (resolvedDevice && resolvedAbsolute) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Convert slashes to backslashes when `resolvedDevice` points to an UNC\r\n  // root. Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    resolvedDevice = normalizeUNCRoot(resolvedDevice);\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path,\r\n  // but handle relative paths to be safe (might happen when process.cwd()\r\n  // fails)\r\n\r\n  // Normalize the tail path\r\n  resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/),\r\n                                !resolvedAbsolute).join('\\\\');\r\n\r\n  return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\r\n         '.';\r\n};\r\n\r\n\r\nwin32.normalize = function(path) {\r\n  var result = win32StatPath(path),\r\n      device = result.device,\r\n      isUnc = result.isUnc,\r\n      isAbsolute = result.isAbsolute,\r\n      tail = result.tail,\r\n      trailingSlash = /[\\\\\\/]$/.test(tail);\r\n\r\n  // Normalize the tail path\r\n  tail = normalizeArray(tail.split(/[\\\\\\/]+/), !isAbsolute).join('\\\\');\r\n\r\n  if (!tail && !isAbsolute) {\r\n    tail = '.';\r\n  }\r\n  if (tail && trailingSlash) {\r\n    tail += '\\\\';\r\n  }\r\n\r\n  // Convert slashes to backslashes when `device` points to an UNC root.\r\n  // Also squash multiple slashes into a single one where appropriate.\r\n  if (isUnc) {\r\n    device = normalizeUNCRoot(device);\r\n  }\r\n\r\n  return device + (isAbsolute ? '\\\\' : '') + tail;\r\n};\r\n\r\n\r\nwin32.isAbsolute = function(path) {\r\n  return win32StatPath(path).isAbsolute;\r\n};\r\n\r\nwin32.join = function() {\r\n  var paths = [];\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var arg = arguments[i];\r\n    if (!util.isString(arg)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (arg) {\r\n      paths.push(arg);\r\n    }\r\n  }\r\n\r\n  var joined = paths.join('\\\\');\r\n\r\n  // Make sure that the joined path doesn't start with two slashes, because\r\n  // normalize() will mistake it for an UNC path then.\r\n  //\r\n  // This step is skipped when it is very clear that the user actually\r\n  // intended to point at an UNC path. This is assumed when the first\r\n  // non-empty string arguments starts with exactly two slashes followed by\r\n  // at least one more non-slash character.\r\n  //\r\n  // Note that for normalize() to treat a path as an UNC path it needs to\r\n  // have at least 2 components, so we don't filter for that here.\r\n  // This means that the user can use join to construct UNC paths from\r\n  // a server name and a share name; for example:\r\n  //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\r\n  if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\r\n    joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\r\n  }\r\n\r\n  return win32.normalize(joined);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// it will solve the relative path from 'from' to 'to', for instance:\r\n// from = 'C:\\\\orandea\\\\test\\\\aaa'\r\n// to = 'C:\\\\orandea\\\\impl\\\\bbb'\r\n// The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\r\nwin32.relative = function(from, to) {\r\n  from = win32.resolve(from);\r\n  to = win32.resolve(to);\r\n\r\n  // windows is not case sensitive\r\n  var lowerFrom = from.toLowerCase();\r\n  var lowerTo = to.toLowerCase();\r\n\r\n  var toParts = trimArray(to.split('\\\\'));\r\n\r\n  var lowerFromParts = trimArray(lowerFrom.split('\\\\'));\r\n  var lowerToParts = trimArray(lowerTo.split('\\\\'));\r\n\r\n  var length = Math.min(lowerFromParts.length, lowerToParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (lowerFromParts[i] !== lowerToParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (samePartsLength == 0) {\r\n    return to;\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < lowerFromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('\\\\');\r\n};\r\n\r\n\r\nwin32._makeLong = function(path) {\r\n  // Note: this will *probably* throw somewhere.\r\n  if (!util.isString(path))\r\n    return path;\r\n\r\n  if (!path) {\r\n    return '';\r\n  }\r\n\r\n  var resolvedPath = win32.resolve(path);\r\n\r\n  if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\r\n    // path is local filesystem path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\' + resolvedPath;\r\n  } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\r\n    // path is network UNC path, which needs to be converted\r\n    // to long UNC path.\r\n    return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\r\n  }\r\n\r\n  return path;\r\n};\r\n\r\n\r\nwin32.dirname = function(path) {\r\n  var result = win32SplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nwin32.basename = function(path, ext) {\r\n  var f = win32SplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nwin32.extname = function(path) {\r\n  return win32SplitPath(path)[3];\r\n};\r\n\r\n\r\nwin32.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir;\r\n  var base = pathObject.base || '';\r\n  if (!dir) {\r\n    return base;\r\n  }\r\n  if (dir[dir.length - 1] === win32.sep) {\r\n    return dir + base;\r\n  }\r\n  return dir + win32.sep + base;\r\n};\r\n\r\n\r\nwin32.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = win32SplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nwin32.sep = '\\\\';\r\nwin32.delimiter = ';';\r\n\r\n\r\n// Split a filename into [root, dir, basename, ext], unix version\r\n// 'root' is just a slash, or nothing.\r\nvar splitPathRe =\r\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\nvar posix = {};\r\n\r\n\r\nfunction posixSplitPath(filename) {\r\n  return splitPathRe.exec(filename).slice(1);\r\n}\r\n\r\n\r\n// path.resolve([from ...], to)\r\n// posix version\r\nposix.resolve = function() {\r\n  var resolvedPath = '',\r\n      resolvedAbsolute = false;\r\n\r\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n    var path = (i >= 0) ? arguments[i] : process.cwd();\r\n\r\n    // Skip empty and invalid entries\r\n    if (!util.isString(path)) {\r\n      throw new TypeError('Arguments to path.resolve must be strings');\r\n    } else if (!path) {\r\n      continue;\r\n    }\r\n\r\n    resolvedPath = path + '/' + resolvedPath;\r\n    resolvedAbsolute = path[0] === '/';\r\n  }\r\n\r\n  // At this point the path should be resolved to a full absolute path, but\r\n  // handle relative paths to be safe (might happen when process.cwd() fails)\r\n\r\n  // Normalize the path\r\n  resolvedPath = normalizeArray(resolvedPath.split('/'),\r\n                                !resolvedAbsolute).join('/');\r\n\r\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n};\r\n\r\n// path.normalize(path)\r\n// posix version\r\nposix.normalize = function(path) {\r\n  var isAbsolute = posix.isAbsolute(path),\r\n      trailingSlash = path && path[path.length - 1] === '/';\r\n\r\n  // Normalize the path\r\n  path = normalizeArray(path.split('/'), !isAbsolute).join('/');\r\n\r\n  if (!path && !isAbsolute) {\r\n    path = '.';\r\n  }\r\n  if (path && trailingSlash) {\r\n    path += '/';\r\n  }\r\n\r\n  return (isAbsolute ? '/' : '') + path;\r\n};\r\n\r\n// posix version\r\nposix.isAbsolute = function(path) {\r\n  return path.charAt(0) === '/';\r\n};\r\n\r\n// posix version\r\nposix.join = function() {\r\n  var path = '';\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    var segment = arguments[i];\r\n    if (!util.isString(segment)) {\r\n      throw new TypeError('Arguments to path.join must be strings');\r\n    }\r\n    if (segment) {\r\n      if (!path) {\r\n        path += segment;\r\n      } else {\r\n        path += '/' + segment;\r\n      }\r\n    }\r\n  }\r\n  return posix.normalize(path);\r\n};\r\n\r\n\r\n// path.relative(from, to)\r\n// posix version\r\nposix.relative = function(from, to) {\r\n  from = posix.resolve(from).substr(1);\r\n  to = posix.resolve(to).substr(1);\r\n\r\n  var fromParts = trimArray(from.split('/'));\r\n  var toParts = trimArray(to.split('/'));\r\n\r\n  var length = Math.min(fromParts.length, toParts.length);\r\n  var samePartsLength = length;\r\n  for (var i = 0; i < length; i++) {\r\n    if (fromParts[i] !== toParts[i]) {\r\n      samePartsLength = i;\r\n      break;\r\n    }\r\n  }\r\n\r\n  var outputParts = [];\r\n  for (var i = samePartsLength; i < fromParts.length; i++) {\r\n    outputParts.push('..');\r\n  }\r\n\r\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n\r\n  return outputParts.join('/');\r\n};\r\n\r\n\r\nposix._makeLong = function(path) {\r\n  return path;\r\n};\r\n\r\n\r\nposix.dirname = function(path) {\r\n  var result = posixSplitPath(path),\r\n      root = result[0],\r\n      dir = result[1];\r\n\r\n  if (!root && !dir) {\r\n    // No dirname whatsoever\r\n    return '.';\r\n  }\r\n\r\n  if (dir) {\r\n    // It has a dirname, strip trailing slash\r\n    dir = dir.substr(0, dir.length - 1);\r\n  }\r\n\r\n  return root + dir;\r\n};\r\n\r\n\r\nposix.basename = function(path, ext) {\r\n  var f = posixSplitPath(path)[2];\r\n  // TODO: make this comparison case-insensitive on windows?\r\n  if (ext && f.substr(-1 * ext.length) === ext) {\r\n    f = f.substr(0, f.length - ext.length);\r\n  }\r\n  return f;\r\n};\r\n\r\n\r\nposix.extname = function(path) {\r\n  return posixSplitPath(path)[3];\r\n};\r\n\r\n\r\nposix.format = function(pathObject) {\r\n  if (!util.isObject(pathObject)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathObject' must be an object, not \" + typeof pathObject\r\n    );\r\n  }\r\n\r\n  var root = pathObject.root || '';\r\n\r\n  if (!util.isString(root)) {\r\n    throw new TypeError(\r\n        \"'pathObject.root' must be a string or undefined, not \" +\r\n        typeof pathObject.root\r\n    );\r\n  }\r\n\r\n  var dir = pathObject.dir ? pathObject.dir + posix.sep : '';\r\n  var base = pathObject.base || '';\r\n  return dir + base;\r\n};\r\n\r\n\r\nposix.parse = function(pathString) {\r\n  if (!util.isString(pathString)) {\r\n    throw new TypeError(\r\n        \"Parameter 'pathString' must be a string, not \" + typeof pathString\r\n    );\r\n  }\r\n  var allParts = posixSplitPath(pathString);\r\n  if (!allParts || allParts.length !== 4) {\r\n    throw new TypeError(\"Invalid path '\" + pathString + \"'\");\r\n  }\r\n  allParts[1] = allParts[1] || '';\r\n  allParts[2] = allParts[2] || '';\r\n  allParts[3] = allParts[3] || '';\r\n\r\n  return {\r\n    root: allParts[0],\r\n    dir: allParts[0] + allParts[1].slice(0, -1),\r\n    base: allParts[2],\r\n    ext: allParts[3],\r\n    name: allParts[2].slice(0, allParts[2].length - allParts[3].length)\r\n  };\r\n};\r\n\r\n\r\nposix.sep = '/';\r\nposix.delimiter = ':';\r\n\r\n\r\nif (isWindows)\r\n  module.exports = win32;\r\nelse /* posix */\r\n  module.exports = posix;\r\n\r\nmodule.exports.posix = posix;\r\nmodule.exports.win32 = win32;\r\n\n\n//# sourceURL=webpack://GloryGameEngine/./node_modules/path/path.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://GloryGameEngine/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(__webpack_require__.g.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n//# sourceURL=webpack://GloryGameEngine/./node_modules/util/util.js?");

/***/ }),

/***/ "./out/engine.out.js":
/*!***************************!*\
  !*** ./out/engine.out.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __dirname = \"/\";\n// include: shell.js\r\n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(moduleArg) => Promise<Module>\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module = typeof Module != 'undefined' ? Module : {};\r\n\r\n// Determine the runtime environment we are in. You can customize this by\r\n// setting the ENVIRONMENT setting at compile time (see settings.js).\r\n\r\n// Attempt to auto-detect the environment\r\nvar ENVIRONMENT_IS_WEB = typeof window == 'object';\r\nvar ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != 'undefined';\r\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\r\n// also a web environment.\r\nvar ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string' && process.type != 'renderer';\r\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n\r\n}\r\n\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\n\r\n\r\n// Sometimes an existing Module object exists with properties\r\n// meant to overwrite the default module functionality. Here\r\n// we collect those properties and reapply _after_ we configure\r\n// the current environment's defaults to avoid having to be so\r\n// defensive during initialization.\r\nvar moduleOverrides = Object.assign({}, Module);\r\n\r\nvar arguments_ = [];\r\nvar thisProgram = './this.program';\r\nvar quit_ = (status, toThrow) => {\r\n  throw toThrow;\r\n};\r\n\r\n// `/` should be present at the end if `scriptDirectory` is not empty\r\nvar scriptDirectory = '';\r\nfunction locateFile(path) {\r\n  if (Module['locateFile']) {\r\n    return Module['locateFile'](path, scriptDirectory);\r\n  }\r\n  return scriptDirectory + path;\r\n}\r\n\r\n// Hooks that are implemented differently in different runtime environments.\r\nvar readAsync, readBinary;\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  var nodeVersion = process.versions.node;\r\n  var numericVersion = nodeVersion.split('.').slice(0, 3);\r\n  numericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);\r\n  var minVersion = 160000;\r\n  if (numericVersion < 160000) {\r\n    throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');\r\n  }\r\n\r\n  // These modules will usually be used on Node.js. Load them eagerly to avoid\r\n  // the complexity of lazy-loading.\r\n  var fs = __webpack_require__(/*! fs */ \"?44c4\");\r\n  var nodePath = __webpack_require__(/*! path */ \"./node_modules/path/path.js\");\r\n\r\n  scriptDirectory = __dirname + '/';\r\n\r\n// include: node_shell_read.js\r\nreadBinary = (filename) => {\r\n  // We need to re-wrap `file://` strings to URLs.\r\n  filename = isFileURI(filename) ? new URL(filename) : filename;\r\n  var ret = fs.readFileSync(filename);\r\n  assert(Buffer.isBuffer(ret));\r\n  return ret;\r\n};\r\n\r\nreadAsync = async (filename, binary = true) => {\r\n  // See the comment in the `readBinary` function.\r\n  filename = isFileURI(filename) ? new URL(filename) : filename;\r\n  var ret = fs.readFileSync(filename, binary ? undefined : 'utf8');\r\n  assert(binary ? Buffer.isBuffer(ret) : typeof ret == 'string');\r\n  return ret;\r\n};\r\n// end include: node_shell_read.js\r\n  if (!Module['thisProgram'] && process.argv.length > 1) {\r\n    thisProgram = process.argv[1].replace(/\\\\/g, '/');\r\n  }\r\n\r\n  arguments_ = process.argv.slice(2);\r\n\r\n  if (true) {\r\n    module['exports'] = Module;\r\n  }\r\n\r\n  quit_ = (status, toThrow) => {\r\n    process.exitCode = status;\r\n    throw toThrow;\r\n  };\r\n\r\n} else\r\nif (ENVIRONMENT_IS_SHELL) {\r\n\r\n  if ((typeof process == 'object' && \"function\" === 'function') || typeof window == 'object' || typeof WorkerGlobalScope != 'undefined') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n} else\r\n\r\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\r\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\r\n// ENVIRONMENT_IS_NODE.\r\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\r\n    scriptDirectory = self.location.href;\r\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\r\n    scriptDirectory = document.currentScript.src;\r\n  }\r\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\r\n  // otherwise, slice off the final part of the url to find the script directory.\r\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\r\n  // and scriptDirectory will correctly be replaced with an empty string.\r\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\r\n  // they are removed because they could contain a slash.\r\n  if (scriptDirectory.startsWith('blob:')) {\r\n    scriptDirectory = '';\r\n  } else {\r\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/')+1);\r\n  }\r\n\r\n  if (!(typeof window == 'object' || typeof WorkerGlobalScope != 'undefined')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  {\r\n// include: web_or_worker_shell_read.js\r\nif (ENVIRONMENT_IS_WORKER) {\r\n    readBinary = (url) => {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, false);\r\n      xhr.responseType = 'arraybuffer';\r\n      xhr.send(null);\r\n      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\r\n    };\r\n  }\r\n\r\n  readAsync = async (url) => {\r\n    // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\r\n    // See https://github.com/github/fetch/pull/92#issuecomment-140665932\r\n    // Cordova or Electron apps are typically loaded from a file:// url.\r\n    // So use XHR on webview if URL is a file URL.\r\n    if (isFileURI(url)) {\r\n      return new Promise((resolve, reject) => {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, true);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.onload = () => {\r\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n            resolve(xhr.response);\r\n            return;\r\n          }\r\n          reject(xhr.status);\r\n        };\r\n        xhr.onerror = reject;\r\n        xhr.send(null);\r\n      });\r\n    }\r\n    var response = await fetch(url, { credentials: 'same-origin' });\r\n    if (response.ok) {\r\n      return response.arrayBuffer();\r\n    }\r\n    throw new Error(response.status + ' : ' + response.url);\r\n  };\r\n// end include: web_or_worker_shell_read.js\r\n  }\r\n} else\r\n{\r\n  throw new Error('environment detection error');\r\n}\r\n\r\nvar out = Module['print'] || console.log.bind(console);\r\nvar err = Module['printErr'] || console.error.bind(console);\r\n\r\n// Merge back in the overrides\r\nObject.assign(Module, moduleOverrides);\r\n// Free the object hierarchy contained in the overrides, this lets the GC\r\n// reclaim data used.\r\nmoduleOverrides = null;\r\ncheckIncomingModuleAPI();\r\n\r\n// Emit code to handle expected values on the Module object. This applies Module.x\r\n// to the proper local x. This has two benefits: first, we only emit it if it is\r\n// expected to arrive, and second, by using a local everywhere else that can be\r\n// minified.\r\n\r\nif (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');\r\n\r\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');\r\n\r\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\r\n// Assertions on removed incoming Module JS APIs.\r\nassert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\r\nassert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\r\nassert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\r\nassert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\r\nassert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\r\nlegacyModuleProp('asm', 'wasmExports');\r\nlegacyModuleProp('readAsync', 'readAsync');\r\nlegacyModuleProp('readBinary', 'readBinary');\r\nlegacyModuleProp('setWindowTitle', 'setWindowTitle');\r\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\r\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\r\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\r\nvar FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\r\nvar ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\r\nvar JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\r\nvar OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\r\n\r\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\r\n\r\nassert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');\r\n\r\n// end include: shell.js\r\n\r\n// include: preamble.js\r\n// === Preamble library stuff ===\r\n\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\nvar wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');\r\n\r\nif (typeof WebAssembly != 'object') {\r\n  err('no native wasm support detected');\r\n}\r\n\r\n// Wasm globals\r\n\r\nvar wasmMemory;\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n\r\n// whether we are quitting the application. no code should run after this.\r\n// set in exit() and abort()\r\nvar ABORT = false;\r\n\r\n// set by exit() and abort().  Passed to 'onExit' handler.\r\n// NOTE: This is also used as the process return code code in shell environments\r\n// but only when noExitRuntime is false.\r\nvar EXITSTATUS;\r\n\r\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\r\n// don't define it at all in release modes.  This matches the behaviour of\r\n// MINIMAL_RUNTIME.\r\n// TODO(sbc): Make this the default even without STRICT enabled.\r\n/** @type {function(*, string=)} */\r\nfunction assert(condition, text) {\r\n  if (!condition) {\r\n    abort('Assertion failed' + (text ? ': ' + text : ''));\r\n  }\r\n}\r\n\r\n// We used to include malloc/free by default in the past. Show a helpful error in\r\n// builds with assertions.\r\nfunction _malloc() {\r\n  abort('malloc() called but not included in the build - add `_malloc` to EXPORTED_FUNCTIONS');\r\n}\r\nfunction _free() {\r\n  // Show a helpful error since we used to include free by default in the past.\r\n  abort('free() called but not included in the build - add `_free` to EXPORTED_FUNCTIONS');\r\n}\r\n\r\n// Memory management\r\n\r\nvar HEAP,\r\n/** @type {!Int8Array} */\r\n  HEAP8,\r\n/** @type {!Uint8Array} */\r\n  HEAPU8,\r\n/** @type {!Int16Array} */\r\n  HEAP16,\r\n/** @type {!Uint16Array} */\r\n  HEAPU16,\r\n/** @type {!Int32Array} */\r\n  HEAP32,\r\n/** @type {!Uint32Array} */\r\n  HEAPU32,\r\n/** @type {!Float32Array} */\r\n  HEAPF32,\r\n/* BigInt64Array type is not correctly defined in closure\r\n/** not-@type {!BigInt64Array} */\r\n  HEAP64,\r\n/* BigUint64Array type is not correctly defined in closure\r\n/** not-t@type {!BigUint64Array} */\r\n  HEAPU64,\r\n/** @type {!Float64Array} */\r\n  HEAPF64;\r\n\r\nvar runtimeInitialized = false;\r\n\r\n// include: URIUtils.js\r\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\r\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\r\n\r\n/**\r\n * Indicates whether filename is a base64 data URI.\r\n * @noinline\r\n */\r\nvar isDataURI = (filename) => filename.startsWith(dataURIPrefix);\r\n\r\n/**\r\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\n * @noinline\r\n */\r\nvar isFileURI = (filename) => filename.startsWith('file://');\r\n// end include: URIUtils.js\r\n// include: runtime_shared.js\r\n// include: runtime_stack_check.js\r\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\r\nfunction writeStackCookie() {\r\n  var max = _emscripten_stack_get_end();\r\n  assert((max & 3) == 0);\r\n  // If the stack ends at address zero we write our cookies 4 bytes into the\r\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\r\n  // monitor writes to address zero.\r\n  if (max == 0) {\r\n    max += 4;\r\n  }\r\n  // The stack grow downwards towards _emscripten_stack_get_end.\r\n  // We write cookies to the final two words in the stack and detect if they are\r\n  // ever overwritten.\r\n  HEAPU32[((max)>>2)] = 0x02135467;\r\n  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\r\n  // Also test the global address 0 for integrity.\r\n  HEAPU32[((0)>>2)] = 1668509029;\r\n}\r\n\r\nfunction checkStackCookie() {\r\n  if (ABORT) return;\r\n  var max = _emscripten_stack_get_end();\r\n  // See writeStackCookie().\r\n  if (max == 0) {\r\n    max += 4;\r\n  }\r\n  var cookie1 = HEAPU32[((max)>>2)];\r\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\r\n  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\r\n    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\r\n  }\r\n  // Also test the global address 0 for integrity.\r\n  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {\r\n    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\r\n  }\r\n}\r\n// end include: runtime_stack_check.js\r\n// include: runtime_exceptions.js\r\n// end include: runtime_exceptions.js\r\n// include: runtime_debug.js\r\n// Endianness check\r\n(() => {\r\n  var h16 = new Int16Array(1);\r\n  var h8 = new Int8Array(h16.buffer);\r\n  h16[0] = 0x6373;\r\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\r\n})();\r\n\r\nif (Module['ENVIRONMENT']) {\r\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\r\n}\r\n\r\nfunction legacyModuleProp(prop, newName, incoming=true) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    Object.defineProperty(Module, prop, {\r\n      configurable: true,\r\n      get() {\r\n        let extra = incoming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';\r\n        abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\r\n\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction ignoredModuleProp(prop) {\r\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\r\n  }\r\n}\r\n\r\n// forcing the filesystem exports a few things by default\r\nfunction isExportedByForceFilesystem(name) {\r\n  return name === 'FS_createPath' ||\r\n         name === 'FS_createDataFile' ||\r\n         name === 'FS_createPreloadedFile' ||\r\n         name === 'FS_unlink' ||\r\n         name === 'addRunDependency' ||\r\n         // The old FS has some functionality that WasmFS lacks.\r\n         name === 'FS_createLazyFile' ||\r\n         name === 'FS_createDevice' ||\r\n         name === 'removeRunDependency';\r\n}\r\n\r\n/**\r\n * Intercept access to a global symbol.  This enables us to give informative\r\n * warnings/errors when folks attempt to use symbols they did not include in\r\n * their build, or no symbols that no longer exist.\r\n */\r\nfunction hookGlobalSymbolAccess(sym, func) {\r\n  if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\r\n    Object.defineProperty(globalThis, sym, {\r\n      configurable: true,\r\n      get() {\r\n        func();\r\n        return undefined;\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction missingGlobal(sym, msg) {\r\n  hookGlobalSymbolAccess(sym, () => {\r\n    warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\r\n  });\r\n}\r\n\r\nmissingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\r\nmissingGlobal('asm', 'Please use wasmExports instead');\r\n\r\nfunction missingLibrarySymbol(sym) {\r\n  hookGlobalSymbolAccess(sym, () => {\r\n    // Can't `abort()` here because it would break code that does runtime\r\n    // checks.  e.g. `if (typeof SDL === 'undefined')`.\r\n    var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\r\n    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\r\n    // library.js, which means $name for a JS name with no prefix, or name\r\n    // for a JS name like _name.\r\n    var librarySymbol = sym;\r\n    if (!librarySymbol.startsWith('_')) {\r\n      librarySymbol = '$' + sym;\r\n    }\r\n    msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\r\n    if (isExportedByForceFilesystem(sym)) {\r\n      msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n    }\r\n    warnOnce(msg);\r\n  });\r\n\r\n  // Any symbol that is not included from the JS library is also (by definition)\r\n  // not exported on the Module object.\r\n  unexportedRuntimeSymbol(sym);\r\n}\r\n\r\nfunction unexportedRuntimeSymbol(sym) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\r\n    Object.defineProperty(Module, sym, {\r\n      configurable: true,\r\n      get() {\r\n        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\r\n        if (isExportedByForceFilesystem(sym)) {\r\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n        }\r\n        abort(msg);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// Used by XXXXX_DEBUG settings to output debug messages.\r\nfunction dbg(...args) {\r\n  // TODO(sbc): Make this configurable somehow.  Its not always convenient for\r\n  // logging to show up as warnings.\r\n  console.warn(...args);\r\n}\r\n// end include: runtime_debug.js\r\n// include: memoryprofiler.js\r\n// end include: memoryprofiler.js\r\n\r\n\r\nfunction updateMemoryViews() {\r\n  var b = wasmMemory.buffer;\r\n  Module['HEAP8'] = HEAP8 = new Int8Array(b);\r\n  Module['HEAP16'] = HEAP16 = new Int16Array(b);\r\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\r\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\r\n  Module['HEAP32'] = HEAP32 = new Int32Array(b);\r\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\r\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\r\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\r\n  Module['HEAP64'] = HEAP64 = new BigInt64Array(b);\r\n  Module['HEAPU64'] = HEAPU64 = new BigUint64Array(b);\r\n}\r\n\r\n// end include: runtime_shared.js\r\nassert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')\r\n\r\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\r\n       'JS engine does not provide full typed array support');\r\n\r\n// If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\r\nassert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\r\nassert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\r\n\r\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\r\nvar __ATINIT__    = []; // functions called during startup\r\nvar __ATMAIN__    = []; // functions called when main() is to be run\r\nvar __ATEXIT__    = []; // functions called during shutdown\r\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\r\n\r\nfunction preRun() {\r\n  if (Module['preRun']) {\r\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\r\n    while (Module['preRun'].length) {\r\n      addOnPreRun(Module['preRun'].shift());\r\n    }\r\n  }\r\n  callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction initRuntime() {\r\n  assert(!runtimeInitialized);\r\n  runtimeInitialized = true;\r\n\r\n  checkStackCookie();\r\n\r\n  \r\nif (!Module['noFSInit'] && !FS.initialized)\r\n  FS.init();\r\nFS.ignorePermissions = false;\r\n\r\nTTY.init();\r\n  callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction preMain() {\r\n  checkStackCookie();\r\n  \r\n  callRuntimeCallbacks(__ATMAIN__);\r\n}\r\n\r\nfunction postRun() {\r\n  checkStackCookie();\r\n\r\n  if (Module['postRun']) {\r\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\r\n    while (Module['postRun'].length) {\r\n      addOnPostRun(Module['postRun'].shift());\r\n    }\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n  __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n  __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnPreMain(cb) {\r\n  __ATMAIN__.unshift(cb);\r\n}\r\n\r\nfunction addOnExit(cb) {\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n  __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// Module.preRun (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\nvar runDependencyTracking = {};\r\nvar runDependencyWatcher = null;\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  var orig = id;\r\n  while (1) {\r\n    if (!runDependencyTracking[id]) return id;\r\n    id = orig + Math.random();\r\n  }\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n\r\n  Module['monitorRunDependencies']?.(runDependencies);\r\n\r\n  if (id) {\r\n    assert(!runDependencyTracking[id]);\r\n    runDependencyTracking[id] = 1;\r\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\r\n      // Check for missing dependencies every few seconds\r\n      runDependencyWatcher = setInterval(() => {\r\n        if (ABORT) {\r\n          clearInterval(runDependencyWatcher);\r\n          runDependencyWatcher = null;\r\n          return;\r\n        }\r\n        var shown = false;\r\n        for (var dep in runDependencyTracking) {\r\n          if (!shown) {\r\n            shown = true;\r\n            err('still waiting on run dependencies:');\r\n          }\r\n          err(`dependency: ${dep}`);\r\n        }\r\n        if (shown) {\r\n          err('(end of list)');\r\n        }\r\n      }, 10000);\r\n    }\r\n  } else {\r\n    err('warning: run dependency added without ID');\r\n  }\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n\r\n  Module['monitorRunDependencies']?.(runDependencies);\r\n\r\n  if (id) {\r\n    assert(runDependencyTracking[id]);\r\n    delete runDependencyTracking[id];\r\n  } else {\r\n    err('warning: run dependency removed without ID');\r\n  }\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback(); // can add another dependenciesFulfilled\r\n    }\r\n  }\r\n}\r\n\r\n/** @param {string|number=} what */\r\nfunction abort(what) {\r\n  Module['onAbort']?.(what);\r\n\r\n  what = 'Aborted(' + what + ')';\r\n  // TODO(sbc): Should we remove printing and leave it up to whoever\r\n  // catches the exception?\r\n  err(what);\r\n\r\n  ABORT = true;\r\n\r\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\r\n  // exception, which means we'd run destructors on it. We need the error to\r\n  // simply make the program stop.\r\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\r\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\r\n  // a trap or not based on a hidden field within the object. So at the moment\r\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\r\n  // allows this in the wasm spec.\r\n\r\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\r\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\r\n  // though it can.\r\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\r\n  /** @suppress {checkTypes} */\r\n  var e = new WebAssembly.RuntimeError(what);\r\n\r\n  // Throw the error whether or not MODULARIZE is set because abort is used\r\n  // in code paths apart from instantiation where an exception is expected\r\n  // to be thrown when abort is called.\r\n  throw e;\r\n}\r\n\r\nfunction createExportWrapper(name, nargs) {\r\n  return (...args) => {\r\n    assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\r\n    var f = wasmExports[name];\r\n    assert(f, `exported native function \\`${name}\\` not found`);\r\n    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\r\n    assert(args.length <= nargs, `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`);\r\n    return f(...args);\r\n  };\r\n}\r\n\r\nvar wasmBinaryFile;\r\nfunction findWasmBinary() {\r\n    var f = 'engine.out.wasm';\r\n    if (!isDataURI(f)) {\r\n      return locateFile(f);\r\n    }\r\n    return f;\r\n}\r\n\r\nfunction getBinarySync(file) {\r\n  if (file == wasmBinaryFile && wasmBinary) {\r\n    return new Uint8Array(wasmBinary);\r\n  }\r\n  if (readBinary) {\r\n    return readBinary(file);\r\n  }\r\n  throw 'both async and sync fetching of the wasm failed';\r\n}\r\n\r\nasync function getWasmBinary(binaryFile) {\r\n  // If we don't have the binary yet, load it asynchronously using readAsync.\r\n  if (!wasmBinary\r\n      ) {\r\n    // Fetch the binary using readAsync\r\n    try {\r\n      var response = await readAsync(binaryFile);\r\n      return new Uint8Array(response);\r\n    } catch {\r\n      // Fall back to getBinarySync below;\r\n    }\r\n  }\r\n\r\n  // Otherwise, getBinarySync should be able to get it synchronously\r\n  return getBinarySync(binaryFile);\r\n}\r\n\r\nasync function instantiateArrayBuffer(binaryFile, imports) {\r\n  try {\r\n    var binary = await getWasmBinary(binaryFile);\r\n    var instance = await WebAssembly.instantiate(binary, imports);\r\n    return instance;\r\n  } catch (reason) {\r\n    err(`failed to asynchronously prepare wasm: ${reason}`);\r\n\r\n    // Warn on some common problems.\r\n    if (isFileURI(wasmBinaryFile)) {\r\n      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\r\n    }\r\n    abort(reason);\r\n  }\r\n}\r\n\r\nasync function instantiateAsync(binary, binaryFile, imports) {\r\n  if (!binary &&\r\n      typeof WebAssembly.instantiateStreaming == 'function' &&\r\n      !isDataURI(binaryFile)\r\n      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\r\n      && !isFileURI(binaryFile)\r\n      // Avoid instantiateStreaming() on Node.js environment for now, as while\r\n      // Node.js v18.1.0 implements it, it does not have a full fetch()\r\n      // implementation yet.\r\n      //\r\n      // Reference:\r\n      //   https://github.com/emscripten-core/emscripten/pull/16917\r\n      && !ENVIRONMENT_IS_NODE\r\n     ) {\r\n    try {\r\n      var response = fetch(binaryFile, { credentials: 'same-origin' });\r\n      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\r\n      return instantiationResult;\r\n    } catch (reason) {\r\n      // We expect the most common failure cause to be a bad MIME type for the binary,\r\n      // in which case falling back to ArrayBuffer instantiation should work.\r\n      err(`wasm streaming compile failed: ${reason}`);\r\n      err('falling back to ArrayBuffer instantiation');\r\n      // fall back of instantiateArrayBuffer below\r\n    };\r\n  }\r\n  return instantiateArrayBuffer(binaryFile, imports);\r\n}\r\n\r\nfunction getWasmImports() {\r\n  // prepare imports\r\n  return {\r\n    'env': wasmImports,\r\n    'wasi_snapshot_preview1': wasmImports,\r\n  }\r\n}\r\n\r\n// Create the wasm instance.\r\n// Receives the wasm imports, returns the exports.\r\nasync function createWasm() {\r\n  // Load the wasm module and create an instance of using native support in the JS engine.\r\n  // handle a generated wasm instance, receiving its exports and\r\n  // performing other necessary setup\r\n  /** @param {WebAssembly.Module=} module*/\r\n  function receiveInstance(instance, module) {\r\n    wasmExports = instance.exports;\r\n\r\n    \r\n\r\n    wasmMemory = wasmExports['memory'];\r\n    \r\n    assert(wasmMemory, 'memory not found in wasm exports');\r\n    updateMemoryViews();\r\n\r\n    addOnInit(wasmExports['__wasm_call_ctors']);\r\n\r\n    removeRunDependency('wasm-instantiate');\r\n    return wasmExports;\r\n  }\r\n  // wait for the pthread pool (if any)\r\n  addRunDependency('wasm-instantiate');\r\n\r\n  // Prefer streaming instantiation if available.\r\n  // Async compilation can be confusing when an error on the page overwrites Module\r\n  // (for example, if the order of elements is wrong, and the one defining Module is\r\n  // later), so we save Module and check it later.\r\n  var trueModule = Module;\r\n  function receiveInstantiationResult(result) {\r\n    // 'result' is a ResultObject object which has both the module and instance.\r\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\r\n    trueModule = null;\r\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\r\n    // When the regression is fixed, can restore the above PTHREADS-enabled path.\r\n    return receiveInstance(result['instance']);\r\n  }\r\n\r\n  var info = getWasmImports();\r\n\r\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n  // to manually instantiate the Wasm module themselves. This allows pages to\r\n  // run the instantiation parallel to any other async startup actions they are\r\n  // performing.\r\n  // Also pthreads and wasm workers initialize the wasm instance through this\r\n  // path.\r\n  if (Module['instantiateWasm']) {\r\n    try {\r\n      return Module['instantiateWasm'](info, receiveInstance);\r\n    } catch(e) {\r\n      err(`Module.instantiateWasm callback failed with error: ${e}`);\r\n        return false;\r\n    }\r\n  }\r\n\r\n  wasmBinaryFile ??= findWasmBinary();\r\n\r\n    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\r\n    var exports = receiveInstantiationResult(result);\r\n    return exports;\r\n}\r\n\r\n// === Body ===\r\n// end include: preamble.js\r\n\r\n\r\n  class ExitStatus {\r\n      name = 'ExitStatus';\r\n      constructor(status) {\r\n        this.message = `Program terminated with exit(${status})`;\r\n        this.status = status;\r\n      }\r\n    }\r\n\r\n  var callRuntimeCallbacks = (callbacks) => {\r\n      while (callbacks.length > 0) {\r\n        // Pass the module as the first argument.\r\n        callbacks.shift()(Module);\r\n      }\r\n    };\r\n\r\n  \r\n    /**\r\n     * @param {number} ptr\r\n     * @param {string} type\r\n     */\r\n  function getValue(ptr, type = 'i8') {\r\n    if (type.endsWith('*')) type = '*';\r\n    switch (type) {\r\n      case 'i1': return HEAP8[ptr];\r\n      case 'i8': return HEAP8[ptr];\r\n      case 'i16': return HEAP16[((ptr)>>1)];\r\n      case 'i32': return HEAP32[((ptr)>>2)];\r\n      case 'i64': return HEAP64[((ptr)>>3)];\r\n      case 'float': return HEAPF32[((ptr)>>2)];\r\n      case 'double': return HEAPF64[((ptr)>>3)];\r\n      case '*': return HEAPU32[((ptr)>>2)];\r\n      default: abort(`invalid type for getValue: ${type}`);\r\n    }\r\n  }\r\n\r\n  var noExitRuntime = Module['noExitRuntime'] || true;\r\n\r\n  var ptrToString = (ptr) => {\r\n      assert(typeof ptr === 'number');\r\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\r\n      ptr >>>= 0;\r\n      return '0x' + ptr.toString(16).padStart(8, '0');\r\n    };\r\n\r\n  \r\n    /**\r\n     * @param {number} ptr\r\n     * @param {number} value\r\n     * @param {string} type\r\n     */\r\n  function setValue(ptr, value, type = 'i8') {\r\n    if (type.endsWith('*')) type = '*';\r\n    switch (type) {\r\n      case 'i1': HEAP8[ptr] = value; break;\r\n      case 'i8': HEAP8[ptr] = value; break;\r\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\r\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\r\n      case 'i64': HEAP64[((ptr)>>3)] = BigInt(value); break;\r\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\r\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\r\n      case '*': HEAPU32[((ptr)>>2)] = value; break;\r\n      default: abort(`invalid type for setValue: ${type}`);\r\n    }\r\n  }\r\n\r\n  var stackRestore = (val) => __emscripten_stack_restore(val);\r\n\r\n  var stackSave = () => _emscripten_stack_get_current();\r\n\r\n  var warnOnce = (text) => {\r\n      warnOnce.shown ||= {};\r\n      if (!warnOnce.shown[text]) {\r\n        warnOnce.shown[text] = 1;\r\n        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;\r\n        err(text);\r\n      }\r\n    };\r\n\r\n  var __abort_js = () =>\r\n      abort('native code called abort()');\r\n\r\n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\r\n      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);\r\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\r\n      // undefined and false each don't write out any bytes.\r\n      if (!(maxBytesToWrite > 0))\r\n        return 0;\r\n  \r\n      var startIdx = outIdx;\r\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n        // unit, not a Unicode code point of the character! So decode\r\n        // UTF16->UTF32->UTF8.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\r\n        // and https://www.ietf.org/rfc/rfc2279.txt\r\n        // and https://tools.ietf.org/html/rfc3629\r\n        var u = str.charCodeAt(i); // possibly a lead surrogate\r\n        if (u >= 0xD800 && u <= 0xDFFF) {\r\n          var u1 = str.charCodeAt(++i);\r\n          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\r\n        }\r\n        if (u <= 0x7F) {\r\n          if (outIdx >= endIdx) break;\r\n          heap[outIdx++] = u;\r\n        } else if (u <= 0x7FF) {\r\n          if (outIdx + 1 >= endIdx) break;\r\n          heap[outIdx++] = 0xC0 | (u >> 6);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        } else if (u <= 0xFFFF) {\r\n          if (outIdx + 2 >= endIdx) break;\r\n          heap[outIdx++] = 0xE0 | (u >> 12);\r\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        } else {\r\n          if (outIdx + 3 >= endIdx) break;\r\n          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\r\n          heap[outIdx++] = 0xF0 | (u >> 18);\r\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        }\r\n      }\r\n      // Null-terminate the pointer to the buffer.\r\n      heap[outIdx] = 0;\r\n      return outIdx - startIdx;\r\n    };\r\n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\r\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\r\n    };\r\n  \r\n  var lengthBytesUTF8 = (str) => {\r\n      var len = 0;\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n        // unit, not a Unicode code point of the character! So decode\r\n        // UTF16->UTF32->UTF8.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        var c = str.charCodeAt(i); // possibly a lead surrogate\r\n        if (c <= 0x7F) {\r\n          len++;\r\n        } else if (c <= 0x7FF) {\r\n          len += 2;\r\n        } else if (c >= 0xD800 && c <= 0xDFFF) {\r\n          len += 4; ++i;\r\n        } else {\r\n          len += 3;\r\n        }\r\n      }\r\n      return len;\r\n    };\r\n  var __tzset_js = (timezone, daylight, std_name, dst_name) => {\r\n      // TODO: Use (malleable) environment variables instead of system settings.\r\n      var currentYear = new Date().getFullYear();\r\n      var winter = new Date(currentYear, 0, 1);\r\n      var summer = new Date(currentYear, 6, 1);\r\n      var winterOffset = winter.getTimezoneOffset();\r\n      var summerOffset = summer.getTimezoneOffset();\r\n  \r\n      // Local standard timezone offset. Local standard time is not adjusted for\r\n      // daylight savings.  This code uses the fact that getTimezoneOffset returns\r\n      // a greater value during Standard Time versus Daylight Saving Time (DST).\r\n      // Thus it determines the expected output during Standard Time, and it\r\n      // compares whether the output of the given date the same (Standard) or less\r\n      // (DST).\r\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\r\n  \r\n      // timezone is specified as seconds west of UTC (\"The external variable\r\n      // `timezone` shall be set to the difference, in seconds, between\r\n      // Coordinated Universal Time (UTC) and local standard time.\"), the same\r\n      // as returned by stdTimezoneOffset.\r\n      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\r\n      HEAPU32[((timezone)>>2)] = stdTimezoneOffset * 60;\r\n  \r\n      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);\r\n  \r\n      var extractZone = (timezoneOffset) => {\r\n        // Why inverse sign?\r\n        // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\r\n        var sign = timezoneOffset >= 0 ? \"-\" : \"+\";\r\n  \r\n        var absOffset = Math.abs(timezoneOffset)\r\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, \"0\");\r\n        var minutes = String(absOffset % 60).padStart(2, \"0\");\r\n  \r\n        return `UTC${sign}${hours}${minutes}`;\r\n      }\r\n  \r\n      var winterName = extractZone(winterOffset);\r\n      var summerName = extractZone(summerOffset);\r\n      assert(winterName);\r\n      assert(summerName);\r\n      assert(lengthBytesUTF8(winterName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${winterName})`);\r\n      assert(lengthBytesUTF8(summerName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${summerName})`);\r\n      if (summerOffset < winterOffset) {\r\n        // Northern hemisphere\r\n        stringToUTF8(winterName, std_name, 17);\r\n        stringToUTF8(summerName, dst_name, 17);\r\n      } else {\r\n        stringToUTF8(winterName, dst_name, 17);\r\n        stringToUTF8(summerName, std_name, 17);\r\n      }\r\n    };\r\n\r\n  var getHeapMax = () =>\r\n      HEAPU8.length;\r\n  \r\n  var alignMemory = (size, alignment) => {\r\n      assert(alignment, \"alignment argument is required\");\r\n      return Math.ceil(size / alignment) * alignment;\r\n    };\r\n  \r\n  var abortOnCannotGrowMemory = (requestedSize) => {\r\n      abort(`Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`);\r\n    };\r\n  var _emscripten_resize_heap = (requestedSize) => {\r\n      var oldSize = HEAPU8.length;\r\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\r\n      requestedSize >>>= 0;\r\n      abortOnCannotGrowMemory(requestedSize);\r\n    };\r\n\r\n  var ENV = {\r\n  };\r\n  \r\n  var getExecutableName = () => thisProgram || './this.program';\r\n  var getEnvStrings = () => {\r\n      if (!getEnvStrings.strings) {\r\n        // Default values.\r\n        // Browser language detection #8751\r\n        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';\r\n        var env = {\r\n          'USER': 'web_user',\r\n          'LOGNAME': 'web_user',\r\n          'PATH': '/',\r\n          'PWD': '/',\r\n          'HOME': '/home/web_user',\r\n          'LANG': lang,\r\n          '_': getExecutableName()\r\n        };\r\n        // Apply the user-provided values, if any.\r\n        for (var x in ENV) {\r\n          // x is a key in ENV; if ENV[x] is undefined, that means it was\r\n          // explicitly set to be so. We allow user code to do that to\r\n          // force variables with default values to remain unset.\r\n          if (ENV[x] === undefined) delete env[x];\r\n          else env[x] = ENV[x];\r\n        }\r\n        var strings = [];\r\n        for (var x in env) {\r\n          strings.push(`${x}=${env[x]}`);\r\n        }\r\n        getEnvStrings.strings = strings;\r\n      }\r\n      return getEnvStrings.strings;\r\n    };\r\n  \r\n  var stringToAscii = (str, buffer) => {\r\n      for (var i = 0; i < str.length; ++i) {\r\n        assert(str.charCodeAt(i) === (str.charCodeAt(i) & 0xff));\r\n        HEAP8[buffer++] = str.charCodeAt(i);\r\n      }\r\n      // Null-terminate the string\r\n      HEAP8[buffer] = 0;\r\n    };\r\n  var _environ_get = (__environ, environ_buf) => {\r\n      var bufSize = 0;\r\n      getEnvStrings().forEach((string, i) => {\r\n        var ptr = environ_buf + bufSize;\r\n        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;\r\n        stringToAscii(string, ptr);\r\n        bufSize += string.length + 1;\r\n      });\r\n      return 0;\r\n    };\r\n\r\n  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\r\n      var strings = getEnvStrings();\r\n      HEAPU32[((penviron_count)>>2)] = strings.length;\r\n      var bufSize = 0;\r\n      strings.forEach((string) => bufSize += string.length + 1);\r\n      HEAPU32[((penviron_buf_size)>>2)] = bufSize;\r\n      return 0;\r\n    };\r\n\r\n  var PATH = {\r\n  isAbs:(path) => path.charAt(0) === '/',\r\n  splitPath:(filename) => {\r\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n        return splitPathRe.exec(filename).slice(1);\r\n      },\r\n  normalizeArray:(parts, allowAboveRoot) => {\r\n        // if the path tries to go above the root, `up` ends up > 0\r\n        var up = 0;\r\n        for (var i = parts.length - 1; i >= 0; i--) {\r\n          var last = parts[i];\r\n          if (last === '.') {\r\n            parts.splice(i, 1);\r\n          } else if (last === '..') {\r\n            parts.splice(i, 1);\r\n            up++;\r\n          } else if (up) {\r\n            parts.splice(i, 1);\r\n            up--;\r\n          }\r\n        }\r\n        // if the path is allowed to go above the root, restore leading ..s\r\n        if (allowAboveRoot) {\r\n          for (; up; up--) {\r\n            parts.unshift('..');\r\n          }\r\n        }\r\n        return parts;\r\n      },\r\n  normalize:(path) => {\r\n        var isAbsolute = PATH.isAbs(path),\r\n            trailingSlash = path.substr(-1) === '/';\r\n        // Normalize the path\r\n        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\r\n        if (!path && !isAbsolute) {\r\n          path = '.';\r\n        }\r\n        if (path && trailingSlash) {\r\n          path += '/';\r\n        }\r\n        return (isAbsolute ? '/' : '') + path;\r\n      },\r\n  dirname:(path) => {\r\n        var result = PATH.splitPath(path),\r\n            root = result[0],\r\n            dir = result[1];\r\n        if (!root && !dir) {\r\n          // No dirname whatsoever\r\n          return '.';\r\n        }\r\n        if (dir) {\r\n          // It has a dirname, strip trailing slash\r\n          dir = dir.substr(0, dir.length - 1);\r\n        }\r\n        return root + dir;\r\n      },\r\n  basename:(path) => path && path.match(/([^\\/]+|\\/)\\/*$/)[1],\r\n  join:(...paths) => PATH.normalize(paths.join('/')),\r\n  join2:(l, r) => PATH.normalize(l + '/' + r),\r\n  };\r\n  \r\n  var initRandomFill = () => {\r\n      // This block is not needed on v19+ since crypto.getRandomValues is builtin\r\n      if (ENVIRONMENT_IS_NODE) {\r\n        var nodeCrypto = __webpack_require__(/*! crypto */ \"?b10a\");\r\n        return (view) => nodeCrypto.randomFillSync(view);\r\n      }\r\n  \r\n      return (view) => crypto.getRandomValues(view);\r\n    };\r\n  var randomFill = (view) => {\r\n      // Lazily init on the first invocation.\r\n      (randomFill = initRandomFill())(view);\r\n    };\r\n  \r\n  \r\n  \r\n  var PATH_FS = {\r\n  resolve:(...args) => {\r\n        var resolvedPath = '',\r\n          resolvedAbsolute = false;\r\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\r\n          var path = (i >= 0) ? args[i] : FS.cwd();\r\n          // Skip empty and invalid entries\r\n          if (typeof path != 'string') {\r\n            throw new TypeError('Arguments to path.resolve must be strings');\r\n          } else if (!path) {\r\n            return ''; // an invalid portion invalidates the whole thing\r\n          }\r\n          resolvedPath = path + '/' + resolvedPath;\r\n          resolvedAbsolute = PATH.isAbs(path);\r\n        }\r\n        // At this point the path should be resolved to a full absolute path, but\r\n        // handle relative paths to be safe (might happen when process.cwd() fails)\r\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\r\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\r\n      },\r\n  relative:(from, to) => {\r\n        from = PATH_FS.resolve(from).substr(1);\r\n        to = PATH_FS.resolve(to).substr(1);\r\n        function trim(arr) {\r\n          var start = 0;\r\n          for (; start < arr.length; start++) {\r\n            if (arr[start] !== '') break;\r\n          }\r\n          var end = arr.length - 1;\r\n          for (; end >= 0; end--) {\r\n            if (arr[end] !== '') break;\r\n          }\r\n          if (start > end) return [];\r\n          return arr.slice(start, end - start + 1);\r\n        }\r\n        var fromParts = trim(from.split('/'));\r\n        var toParts = trim(to.split('/'));\r\n        var length = Math.min(fromParts.length, toParts.length);\r\n        var samePartsLength = length;\r\n        for (var i = 0; i < length; i++) {\r\n          if (fromParts[i] !== toParts[i]) {\r\n            samePartsLength = i;\r\n            break;\r\n          }\r\n        }\r\n        var outputParts = [];\r\n        for (var i = samePartsLength; i < fromParts.length; i++) {\r\n          outputParts.push('..');\r\n        }\r\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\r\n        return outputParts.join('/');\r\n      },\r\n  };\r\n  \r\n  \r\n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\r\n  \r\n    /**\r\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\r\n     * array that contains uint8 values, returns a copy of that string as a\r\n     * Javascript String object.\r\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n     * @param {number=} idx\r\n     * @param {number=} maxBytesToRead\r\n     * @return {string}\r\n     */\r\n  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\r\n      var endIdx = idx + maxBytesToRead;\r\n      var endPtr = idx;\r\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n      // null terminator by itself.  Also, use the length info to avoid running tiny\r\n      // strings through TextDecoder, since .subarray() allocates garbage.\r\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\r\n      // so that undefined/NaN means Infinity)\r\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n  \r\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\r\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\r\n      }\r\n      var str = '';\r\n      // If building with TextDecoder, we have already computed the string length\r\n      // above, so test loop end condition against that\r\n      while (idx < endPtr) {\r\n        // For UTF8 byte structure, see:\r\n        // http://en.wikipedia.org/wiki/UTF-8#Description\r\n        // https://www.ietf.org/rfc/rfc2279.txt\r\n        // https://tools.ietf.org/html/rfc3629\r\n        var u0 = heapOrArray[idx++];\r\n        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\r\n        var u1 = heapOrArray[idx++] & 63;\r\n        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\r\n        var u2 = heapOrArray[idx++] & 63;\r\n        if ((u0 & 0xF0) == 0xE0) {\r\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n        } else {\r\n          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\r\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\r\n        }\r\n  \r\n        if (u0 < 0x10000) {\r\n          str += String.fromCharCode(u0);\r\n        } else {\r\n          var ch = u0 - 0x10000;\r\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n        }\r\n      }\r\n      return str;\r\n    };\r\n  \r\n  var FS_stdin_getChar_buffer = [];\r\n  \r\n  \r\n  /** @type {function(string, boolean=, number=)} */\r\n  function intArrayFromString(stringy, dontAddNull, length) {\r\n    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\r\n    var u8array = new Array(len);\r\n    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\r\n    if (dontAddNull) u8array.length = numBytesWritten;\r\n    return u8array;\r\n  }\r\n  var FS_stdin_getChar = () => {\r\n      if (!FS_stdin_getChar_buffer.length) {\r\n        var result = null;\r\n        if (ENVIRONMENT_IS_NODE) {\r\n          // we will read data by chunks of BUFSIZE\r\n          var BUFSIZE = 256;\r\n          var buf = Buffer.alloc(BUFSIZE);\r\n          var bytesRead = 0;\r\n  \r\n          // For some reason we must suppress a closure warning here, even though\r\n          // fd definitely exists on process.stdin, and is even the proper way to\r\n          // get the fd of stdin,\r\n          // https://github.com/nodejs/help/issues/2136#issuecomment-523649904\r\n          // This started to happen after moving this logic out of library_tty.js,\r\n          // so it is related to the surrounding code in some unclear manner.\r\n          /** @suppress {missingProperties} */\r\n          var fd = process.stdin.fd;\r\n  \r\n          try {\r\n            bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);\r\n          } catch(e) {\r\n            // Cross-platform differences: on Windows, reading EOF throws an\r\n            // exception, but on other OSes, reading EOF returns 0. Uniformize\r\n            // behavior by treating the EOF exception to return 0.\r\n            if (e.toString().includes('EOF')) bytesRead = 0;\r\n            else throw e;\r\n          }\r\n  \r\n          if (bytesRead > 0) {\r\n            result = buf.slice(0, bytesRead).toString('utf-8');\r\n          }\r\n        } else\r\n        if (typeof window != 'undefined' &&\r\n          typeof window.prompt == 'function') {\r\n          // Browser.\r\n          result = window.prompt('Input: ');  // returns null on cancel\r\n          if (result !== null) {\r\n            result += '\\n';\r\n          }\r\n        } else\r\n        {}\r\n        if (!result) {\r\n          return null;\r\n        }\r\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\r\n      }\r\n      return FS_stdin_getChar_buffer.shift();\r\n    };\r\n  var TTY = {\r\n  ttys:[],\r\n  init() {\r\n        // https://github.com/emscripten-core/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\r\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\r\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\r\n        //   // with text files until FS.init can be refactored.\r\n        //   process.stdin.setEncoding('utf8');\r\n        // }\r\n      },\r\n  shutdown() {\r\n        // https://github.com/emscripten-core/emscripten/pull/1555\r\n        // if (ENVIRONMENT_IS_NODE) {\r\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\r\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\r\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\r\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\r\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\r\n        //   process.stdin.pause();\r\n        // }\r\n      },\r\n  register(dev, ops) {\r\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\r\n        FS.registerDevice(dev, TTY.stream_ops);\r\n      },\r\n  stream_ops:{\r\n  open(stream) {\r\n          var tty = TTY.ttys[stream.node.rdev];\r\n          if (!tty) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          stream.tty = tty;\r\n          stream.seekable = false;\r\n        },\r\n  close(stream) {\r\n          // flush any pending line data\r\n          stream.tty.ops.fsync(stream.tty);\r\n        },\r\n  fsync(stream) {\r\n          stream.tty.ops.fsync(stream.tty);\r\n        },\r\n  read(stream, buffer, offset, length, pos /* ignored */) {\r\n          if (!stream.tty || !stream.tty.ops.get_char) {\r\n            throw new FS.ErrnoError(60);\r\n          }\r\n          var bytesRead = 0;\r\n          for (var i = 0; i < length; i++) {\r\n            var result;\r\n            try {\r\n              result = stream.tty.ops.get_char(stream.tty);\r\n            } catch (e) {\r\n              throw new FS.ErrnoError(29);\r\n            }\r\n            if (result === undefined && bytesRead === 0) {\r\n              throw new FS.ErrnoError(6);\r\n            }\r\n            if (result === null || result === undefined) break;\r\n            bytesRead++;\r\n            buffer[offset+i] = result;\r\n          }\r\n          if (bytesRead) {\r\n            stream.node.atime = Date.now();\r\n          }\r\n          return bytesRead;\r\n        },\r\n  write(stream, buffer, offset, length, pos) {\r\n          if (!stream.tty || !stream.tty.ops.put_char) {\r\n            throw new FS.ErrnoError(60);\r\n          }\r\n          try {\r\n            for (var i = 0; i < length; i++) {\r\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\r\n            }\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n          if (length) {\r\n            stream.node.mtime = stream.node.ctime = Date.now();\r\n          }\r\n          return i;\r\n        },\r\n  },\r\n  default_tty_ops:{\r\n  get_char(tty) {\r\n          return FS_stdin_getChar();\r\n        },\r\n  put_char(tty, val) {\r\n          if (val === null || val === 10) {\r\n            out(UTF8ArrayToString(tty.output));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\r\n          }\r\n        },\r\n  fsync(tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            out(UTF8ArrayToString(tty.output));\r\n            tty.output = [];\r\n          }\r\n        },\r\n  ioctl_tcgets(tty) {\r\n          // typical setting\r\n          return {\r\n            c_iflag: 25856,\r\n            c_oflag: 5,\r\n            c_cflag: 191,\r\n            c_lflag: 35387,\r\n            c_cc: [\r\n              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,\r\n              0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n            ]\r\n          };\r\n        },\r\n  ioctl_tcsets(tty, optional_actions, data) {\r\n          // currently just ignore\r\n          return 0;\r\n        },\r\n  ioctl_tiocgwinsz(tty) {\r\n          return [24, 80];\r\n        },\r\n  },\r\n  default_tty1_ops:{\r\n  put_char(tty, val) {\r\n          if (val === null || val === 10) {\r\n            err(UTF8ArrayToString(tty.output));\r\n            tty.output = [];\r\n          } else {\r\n            if (val != 0) tty.output.push(val);\r\n          }\r\n        },\r\n  fsync(tty) {\r\n          if (tty.output && tty.output.length > 0) {\r\n            err(UTF8ArrayToString(tty.output));\r\n            tty.output = [];\r\n          }\r\n        },\r\n  },\r\n  };\r\n  \r\n  \r\n  var zeroMemory = (address, size) => {\r\n      HEAPU8.fill(0, address, address + size);\r\n    };\r\n  \r\n  var mmapAlloc = (size) => {\r\n      abort('internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported');\r\n    };\r\n  var MEMFS = {\r\n  ops_table:null,\r\n  mount(mount) {\r\n        return MEMFS.createNode(null, '/', 16895, 0);\r\n      },\r\n  createNode(parent, name, mode, dev) {\r\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\r\n          // no supported\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        MEMFS.ops_table ||= {\r\n          dir: {\r\n            node: {\r\n              getattr: MEMFS.node_ops.getattr,\r\n              setattr: MEMFS.node_ops.setattr,\r\n              lookup: MEMFS.node_ops.lookup,\r\n              mknod: MEMFS.node_ops.mknod,\r\n              rename: MEMFS.node_ops.rename,\r\n              unlink: MEMFS.node_ops.unlink,\r\n              rmdir: MEMFS.node_ops.rmdir,\r\n              readdir: MEMFS.node_ops.readdir,\r\n              symlink: MEMFS.node_ops.symlink\r\n            },\r\n            stream: {\r\n              llseek: MEMFS.stream_ops.llseek\r\n            }\r\n          },\r\n          file: {\r\n            node: {\r\n              getattr: MEMFS.node_ops.getattr,\r\n              setattr: MEMFS.node_ops.setattr\r\n            },\r\n            stream: {\r\n              llseek: MEMFS.stream_ops.llseek,\r\n              read: MEMFS.stream_ops.read,\r\n              write: MEMFS.stream_ops.write,\r\n              allocate: MEMFS.stream_ops.allocate,\r\n              mmap: MEMFS.stream_ops.mmap,\r\n              msync: MEMFS.stream_ops.msync\r\n            }\r\n          },\r\n          link: {\r\n            node: {\r\n              getattr: MEMFS.node_ops.getattr,\r\n              setattr: MEMFS.node_ops.setattr,\r\n              readlink: MEMFS.node_ops.readlink\r\n            },\r\n            stream: {}\r\n          },\r\n          chrdev: {\r\n            node: {\r\n              getattr: MEMFS.node_ops.getattr,\r\n              setattr: MEMFS.node_ops.setattr\r\n            },\r\n            stream: FS.chrdev_stream_ops\r\n          }\r\n        };\r\n        var node = FS.createNode(parent, name, mode, dev);\r\n        if (FS.isDir(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.dir.node;\r\n          node.stream_ops = MEMFS.ops_table.dir.stream;\r\n          node.contents = {};\r\n        } else if (FS.isFile(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.file.node;\r\n          node.stream_ops = MEMFS.ops_table.file.stream;\r\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\r\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\r\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\r\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\r\n          node.contents = null; \r\n        } else if (FS.isLink(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.link.node;\r\n          node.stream_ops = MEMFS.ops_table.link.stream;\r\n        } else if (FS.isChrdev(node.mode)) {\r\n          node.node_ops = MEMFS.ops_table.chrdev.node;\r\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\r\n        }\r\n        node.atime = node.mtime = node.ctime = Date.now();\r\n        // add the new node to the parent\r\n        if (parent) {\r\n          parent.contents[name] = node;\r\n          parent.atime = parent.mtime = parent.ctime = node.atime;\r\n        }\r\n        return node;\r\n      },\r\n  getFileDataAsTypedArray(node) {\r\n        if (!node.contents) return new Uint8Array(0);\r\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\r\n        return new Uint8Array(node.contents);\r\n      },\r\n  expandFileStorage(node, newCapacity) {\r\n        var prevCapacity = node.contents ? node.contents.length : 0;\r\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\r\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\r\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\r\n        // avoid overshooting the allocation cap by a very large margin.\r\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\r\n        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\r\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\r\n        var oldContents = node.contents;\r\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\r\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\r\n      },\r\n  resizeFileStorage(node, newSize) {\r\n        if (node.usedBytes == newSize) return;\r\n        if (newSize == 0) {\r\n          node.contents = null; // Fully decommit when requesting a resize to zero.\r\n          node.usedBytes = 0;\r\n        } else {\r\n          var oldContents = node.contents;\r\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\r\n          if (oldContents) {\r\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\r\n          }\r\n          node.usedBytes = newSize;\r\n        }\r\n      },\r\n  node_ops:{\r\n  getattr(node) {\r\n          var attr = {};\r\n          // device numbers reuse inode numbers.\r\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\r\n          attr.ino = node.id;\r\n          attr.mode = node.mode;\r\n          attr.nlink = 1;\r\n          attr.uid = 0;\r\n          attr.gid = 0;\r\n          attr.rdev = node.rdev;\r\n          if (FS.isDir(node.mode)) {\r\n            attr.size = 4096;\r\n          } else if (FS.isFile(node.mode)) {\r\n            attr.size = node.usedBytes;\r\n          } else if (FS.isLink(node.mode)) {\r\n            attr.size = node.link.length;\r\n          } else {\r\n            attr.size = 0;\r\n          }\r\n          attr.atime = new Date(node.atime);\r\n          attr.mtime = new Date(node.mtime);\r\n          attr.ctime = new Date(node.ctime);\r\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\r\n          //       but this is not required by the standard.\r\n          attr.blksize = 4096;\r\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\r\n          return attr;\r\n        },\r\n  setattr(node, attr) {\r\n          for (const key of [\"mode\", \"atime\", \"mtime\", \"ctime\"]) {\r\n            if (attr[key] != null) {\r\n              node[key] = attr[key];\r\n            }\r\n          }\r\n          if (attr.size !== undefined) {\r\n            MEMFS.resizeFileStorage(node, attr.size);\r\n          }\r\n        },\r\n  lookup(parent, name) {\r\n          throw new FS.ErrnoError(44);\r\n        },\r\n  mknod(parent, name, mode, dev) {\r\n          return MEMFS.createNode(parent, name, mode, dev);\r\n        },\r\n  rename(old_node, new_dir, new_name) {\r\n          var new_node;\r\n          try {\r\n            new_node = FS.lookupNode(new_dir, new_name);\r\n          } catch (e) {}\r\n          if (new_node) {\r\n            if (FS.isDir(old_node.mode)) {\r\n              // if we're overwriting a directory at new_name, make sure it's empty.\r\n              for (var i in new_node.contents) {\r\n                throw new FS.ErrnoError(55);\r\n              }\r\n            }\r\n            FS.hashRemoveNode(new_node);\r\n          }\r\n          // do the internal rewiring\r\n          delete old_node.parent.contents[old_node.name];\r\n          new_dir.contents[new_name] = old_node;\r\n          old_node.name = new_name;\r\n          new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();\r\n        },\r\n  unlink(parent, name) {\r\n          delete parent.contents[name];\r\n          parent.ctime = parent.mtime = Date.now();\r\n        },\r\n  rmdir(parent, name) {\r\n          var node = FS.lookupNode(parent, name);\r\n          for (var i in node.contents) {\r\n            throw new FS.ErrnoError(55);\r\n          }\r\n          delete parent.contents[name];\r\n          parent.ctime = parent.mtime = Date.now();\r\n        },\r\n  readdir(node) {\r\n          return ['.', '..', ...Object.keys(node.contents)];\r\n        },\r\n  symlink(parent, newname, oldpath) {\r\n          var node = MEMFS.createNode(parent, newname, 0o777 | 40960, 0);\r\n          node.link = oldpath;\r\n          return node;\r\n        },\r\n  readlink(node) {\r\n          if (!FS.isLink(node.mode)) {\r\n            throw new FS.ErrnoError(28);\r\n          }\r\n          return node.link;\r\n        },\r\n  },\r\n  stream_ops:{\r\n  read(stream, buffer, offset, length, position) {\r\n          var contents = stream.node.contents;\r\n          if (position >= stream.node.usedBytes) return 0;\r\n          var size = Math.min(stream.node.usedBytes - position, length);\r\n          assert(size >= 0);\r\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\r\n            buffer.set(contents.subarray(position, position + size), offset);\r\n          } else {\r\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\r\n          }\r\n          return size;\r\n        },\r\n  write(stream, buffer, offset, length, position, canOwn) {\r\n          // The data buffer should be a typed array view\r\n          assert(!(buffer instanceof ArrayBuffer));\r\n  \r\n          if (!length) return 0;\r\n          var node = stream.node;\r\n          node.mtime = node.ctime = Date.now();\r\n  \r\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\r\n            if (canOwn) {\r\n              assert(position === 0, 'canOwn must imply no weird position inside the file');\r\n              node.contents = buffer.subarray(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\r\n              node.contents = buffer.slice(offset, offset + length);\r\n              node.usedBytes = length;\r\n              return length;\r\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\r\n              node.contents.set(buffer.subarray(offset, offset + length), position);\r\n              return length;\r\n            }\r\n          }\r\n  \r\n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\r\n          MEMFS.expandFileStorage(node, position+length);\r\n          if (node.contents.subarray && buffer.subarray) {\r\n            // Use typed array write which is available.\r\n            node.contents.set(buffer.subarray(offset, offset + length), position);\r\n          } else {\r\n            for (var i = 0; i < length; i++) {\r\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\r\n            }\r\n          }\r\n          node.usedBytes = Math.max(node.usedBytes, position + length);\r\n          return length;\r\n        },\r\n  llseek(stream, offset, whence) {\r\n          var position = offset;\r\n          if (whence === 1) {\r\n            position += stream.position;\r\n          } else if (whence === 2) {\r\n            if (FS.isFile(stream.node.mode)) {\r\n              position += stream.node.usedBytes;\r\n            }\r\n          }\r\n          if (position < 0) {\r\n            throw new FS.ErrnoError(28);\r\n          }\r\n          return position;\r\n        },\r\n  allocate(stream, offset, length) {\r\n          MEMFS.expandFileStorage(stream.node, offset + length);\r\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\r\n        },\r\n  mmap(stream, length, position, prot, flags) {\r\n          if (!FS.isFile(stream.node.mode)) {\r\n            throw new FS.ErrnoError(43);\r\n          }\r\n          var ptr;\r\n          var allocated;\r\n          var contents = stream.node.contents;\r\n          // Only make a new copy when MAP_PRIVATE is specified.\r\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\r\n            // We can't emulate MAP_SHARED when the file is not backed by the\r\n            // buffer we're mapping to (e.g. the HEAP buffer).\r\n            allocated = false;\r\n            ptr = contents.byteOffset;\r\n          } else {\r\n            allocated = true;\r\n            ptr = mmapAlloc(length);\r\n            if (!ptr) {\r\n              throw new FS.ErrnoError(48);\r\n            }\r\n            if (contents) {\r\n              // Try to avoid unnecessary slices.\r\n              if (position > 0 || position + length < contents.length) {\r\n                if (contents.subarray) {\r\n                  contents = contents.subarray(position, position + length);\r\n                } else {\r\n                  contents = Array.prototype.slice.call(contents, position, position + length);\r\n                }\r\n              }\r\n              HEAP8.set(contents, ptr);\r\n            }\r\n          }\r\n          return { ptr, allocated };\r\n        },\r\n  msync(stream, buffer, offset, length, mmapFlags) {\r\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\r\n          // should we check if bytesWritten and length are the same?\r\n          return 0;\r\n        },\r\n  },\r\n  };\r\n  \r\n  var asyncLoad = async (url) => {\r\n      var arrayBuffer = await readAsync(url);\r\n      assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\r\n      return new Uint8Array(arrayBuffer);\r\n    };\r\n  \r\n  \r\n  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {\r\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\r\n    };\r\n  \r\n  var preloadPlugins = Module['preloadPlugins'] || [];\r\n  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {\r\n      // Ensure plugins are ready.\r\n      if (typeof Browser != 'undefined') Browser.init();\r\n  \r\n      var handled = false;\r\n      preloadPlugins.forEach((plugin) => {\r\n        if (handled) return;\r\n        if (plugin['canHandle'](fullname)) {\r\n          plugin['handle'](byteArray, fullname, finish, onerror);\r\n          handled = true;\r\n        }\r\n      });\r\n      return handled;\r\n    };\r\n  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\r\n      // TODO we should allow people to just pass in a complete filename instead\r\n      // of parent and name being that we just join them anyways\r\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\r\n      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname\r\n      function processData(byteArray) {\r\n        function finish(byteArray) {\r\n          preFinish?.();\r\n          if (!dontCreateFile) {\r\n            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\r\n          }\r\n          onload?.();\r\n          removeRunDependency(dep);\r\n        }\r\n        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {\r\n          onerror?.();\r\n          removeRunDependency(dep);\r\n        })) {\r\n          return;\r\n        }\r\n        finish(byteArray);\r\n      }\r\n      addRunDependency(dep);\r\n      if (typeof url == 'string') {\r\n        asyncLoad(url).then(processData, onerror);\r\n      } else {\r\n        processData(url);\r\n      }\r\n    };\r\n  \r\n  var FS_modeStringToFlags = (str) => {\r\n      var flagModes = {\r\n        'r': 0,\r\n        'r+': 2,\r\n        'w': 512 | 64 | 1,\r\n        'w+': 512 | 64 | 2,\r\n        'a': 1024 | 64 | 1,\r\n        'a+': 1024 | 64 | 2,\r\n      };\r\n      var flags = flagModes[str];\r\n      if (typeof flags == 'undefined') {\r\n        throw new Error(`Unknown file open mode: ${str}`);\r\n      }\r\n      return flags;\r\n    };\r\n  \r\n  var FS_getMode = (canRead, canWrite) => {\r\n      var mode = 0;\r\n      if (canRead) mode |= 292 | 73;\r\n      if (canWrite) mode |= 146;\r\n      return mode;\r\n    };\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n    /**\r\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\r\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\r\n     *\r\n     * @param {number} ptr\r\n     * @param {number=} maxBytesToRead - An optional length that specifies the\r\n     *   maximum number of bytes to read. You can omit this parameter to scan the\r\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\r\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\r\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\r\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\r\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\r\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\r\n     * @return {string}\r\n     */\r\n  var UTF8ToString = (ptr, maxBytesToRead) => {\r\n      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);\r\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\r\n    };\r\n  \r\n  var strError = (errno) => UTF8ToString(_strerror(errno));\r\n  \r\n  var ERRNO_CODES = {\r\n      'EPERM': 63,\r\n      'ENOENT': 44,\r\n      'ESRCH': 71,\r\n      'EINTR': 27,\r\n      'EIO': 29,\r\n      'ENXIO': 60,\r\n      'E2BIG': 1,\r\n      'ENOEXEC': 45,\r\n      'EBADF': 8,\r\n      'ECHILD': 12,\r\n      'EAGAIN': 6,\r\n      'EWOULDBLOCK': 6,\r\n      'ENOMEM': 48,\r\n      'EACCES': 2,\r\n      'EFAULT': 21,\r\n      'ENOTBLK': 105,\r\n      'EBUSY': 10,\r\n      'EEXIST': 20,\r\n      'EXDEV': 75,\r\n      'ENODEV': 43,\r\n      'ENOTDIR': 54,\r\n      'EISDIR': 31,\r\n      'EINVAL': 28,\r\n      'ENFILE': 41,\r\n      'EMFILE': 33,\r\n      'ENOTTY': 59,\r\n      'ETXTBSY': 74,\r\n      'EFBIG': 22,\r\n      'ENOSPC': 51,\r\n      'ESPIPE': 70,\r\n      'EROFS': 69,\r\n      'EMLINK': 34,\r\n      'EPIPE': 64,\r\n      'EDOM': 18,\r\n      'ERANGE': 68,\r\n      'ENOMSG': 49,\r\n      'EIDRM': 24,\r\n      'ECHRNG': 106,\r\n      'EL2NSYNC': 156,\r\n      'EL3HLT': 107,\r\n      'EL3RST': 108,\r\n      'ELNRNG': 109,\r\n      'EUNATCH': 110,\r\n      'ENOCSI': 111,\r\n      'EL2HLT': 112,\r\n      'EDEADLK': 16,\r\n      'ENOLCK': 46,\r\n      'EBADE': 113,\r\n      'EBADR': 114,\r\n      'EXFULL': 115,\r\n      'ENOANO': 104,\r\n      'EBADRQC': 103,\r\n      'EBADSLT': 102,\r\n      'EDEADLOCK': 16,\r\n      'EBFONT': 101,\r\n      'ENOSTR': 100,\r\n      'ENODATA': 116,\r\n      'ETIME': 117,\r\n      'ENOSR': 118,\r\n      'ENONET': 119,\r\n      'ENOPKG': 120,\r\n      'EREMOTE': 121,\r\n      'ENOLINK': 47,\r\n      'EADV': 122,\r\n      'ESRMNT': 123,\r\n      'ECOMM': 124,\r\n      'EPROTO': 65,\r\n      'EMULTIHOP': 36,\r\n      'EDOTDOT': 125,\r\n      'EBADMSG': 9,\r\n      'ENOTUNIQ': 126,\r\n      'EBADFD': 127,\r\n      'EREMCHG': 128,\r\n      'ELIBACC': 129,\r\n      'ELIBBAD': 130,\r\n      'ELIBSCN': 131,\r\n      'ELIBMAX': 132,\r\n      'ELIBEXEC': 133,\r\n      'ENOSYS': 52,\r\n      'ENOTEMPTY': 55,\r\n      'ENAMETOOLONG': 37,\r\n      'ELOOP': 32,\r\n      'EOPNOTSUPP': 138,\r\n      'EPFNOSUPPORT': 139,\r\n      'ECONNRESET': 15,\r\n      'ENOBUFS': 42,\r\n      'EAFNOSUPPORT': 5,\r\n      'EPROTOTYPE': 67,\r\n      'ENOTSOCK': 57,\r\n      'ENOPROTOOPT': 50,\r\n      'ESHUTDOWN': 140,\r\n      'ECONNREFUSED': 14,\r\n      'EADDRINUSE': 3,\r\n      'ECONNABORTED': 13,\r\n      'ENETUNREACH': 40,\r\n      'ENETDOWN': 38,\r\n      'ETIMEDOUT': 73,\r\n      'EHOSTDOWN': 142,\r\n      'EHOSTUNREACH': 23,\r\n      'EINPROGRESS': 26,\r\n      'EALREADY': 7,\r\n      'EDESTADDRREQ': 17,\r\n      'EMSGSIZE': 35,\r\n      'EPROTONOSUPPORT': 66,\r\n      'ESOCKTNOSUPPORT': 137,\r\n      'EADDRNOTAVAIL': 4,\r\n      'ENETRESET': 39,\r\n      'EISCONN': 30,\r\n      'ENOTCONN': 53,\r\n      'ETOOMANYREFS': 141,\r\n      'EUSERS': 136,\r\n      'EDQUOT': 19,\r\n      'ESTALE': 72,\r\n      'ENOTSUP': 138,\r\n      'ENOMEDIUM': 148,\r\n      'EILSEQ': 25,\r\n      'EOVERFLOW': 61,\r\n      'ECANCELED': 11,\r\n      'ENOTRECOVERABLE': 56,\r\n      'EOWNERDEAD': 62,\r\n      'ESTRPIPE': 135,\r\n    };\r\n  var FS = {\r\n  root:null,\r\n  mounts:[],\r\n  devices:{\r\n  },\r\n  streams:[],\r\n  nextInode:1,\r\n  nameTable:null,\r\n  currentPath:\"/\",\r\n  initialized:false,\r\n  ignorePermissions:true,\r\n  ErrnoError:class extends Error {\r\n        name = 'ErrnoError';\r\n        // We set the `name` property to be able to identify `FS.ErrnoError`\r\n        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\r\n        // - when using PROXYFS, an error can come from an underlying FS\r\n        // as different FS objects have their own FS.ErrnoError each,\r\n        // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\r\n        // we'll use the reliable test `err.name == \"ErrnoError\"` instead\r\n        constructor(errno) {\r\n          super(runtimeInitialized ? strError(errno) : '');\r\n          this.errno = errno;\r\n          for (var key in ERRNO_CODES) {\r\n            if (ERRNO_CODES[key] === errno) {\r\n              this.code = key;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      },\r\n  filesystems:null,\r\n  syncFSRequests:0,\r\n  readFiles:{\r\n  },\r\n  FSStream:class {\r\n        shared = {};\r\n        get object() {\r\n          return this.node;\r\n        }\r\n        set object(val) {\r\n          this.node = val;\r\n        }\r\n        get isRead() {\r\n          return (this.flags & 2097155) !== 1;\r\n        }\r\n        get isWrite() {\r\n          return (this.flags & 2097155) !== 0;\r\n        }\r\n        get isAppend() {\r\n          return (this.flags & 1024);\r\n        }\r\n        get flags() {\r\n          return this.shared.flags;\r\n        }\r\n        set flags(val) {\r\n          this.shared.flags = val;\r\n        }\r\n        get position() {\r\n          return this.shared.position;\r\n        }\r\n        set position(val) {\r\n          this.shared.position = val;\r\n        }\r\n      },\r\n  FSNode:class {\r\n        node_ops = {};\r\n        stream_ops = {};\r\n        readMode = 292 | 73;\r\n        writeMode = 146;\r\n        mounted = null;\r\n        constructor(parent, name, mode, rdev) {\r\n          if (!parent) {\r\n            parent = this;  // root node sets parent to itself\r\n          }\r\n          this.parent = parent;\r\n          this.mount = parent.mount;\r\n          this.id = FS.nextInode++;\r\n          this.name = name;\r\n          this.mode = mode;\r\n          this.rdev = rdev;\r\n          this.atime = this.mtime = this.ctime = Date.now();\r\n        }\r\n        get read() {\r\n          return (this.mode & this.readMode) === this.readMode;\r\n        }\r\n        set read(val) {\r\n          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\r\n        }\r\n        get write() {\r\n          return (this.mode & this.writeMode) === this.writeMode;\r\n        }\r\n        set write(val) {\r\n          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\r\n        }\r\n        get isFolder() {\r\n          return FS.isDir(this.mode);\r\n        }\r\n        get isDevice() {\r\n          return FS.isChrdev(this.mode);\r\n        }\r\n      },\r\n  lookupPath(path, opts = {}) {\r\n        if (!path) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        opts.follow_mount ??= true\r\n  \r\n        if (!PATH.isAbs(path)) {\r\n          path = FS.cwd() + '/' + path;\r\n        }\r\n  \r\n        // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\r\n        linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {\r\n          // split the absolute path\r\n          var parts = path.split('/').filter((p) => !!p);\r\n  \r\n          // start at the root\r\n          var current = FS.root;\r\n          var current_path = '/';\r\n  \r\n          for (var i = 0; i < parts.length; i++) {\r\n            var islast = (i === parts.length-1);\r\n            if (islast && opts.parent) {\r\n              // stop resolving\r\n              break;\r\n            }\r\n  \r\n            if (parts[i] === '.') {\r\n              continue;\r\n            }\r\n  \r\n            if (parts[i] === '..') {\r\n              current_path = PATH.dirname(current_path);\r\n              current = current.parent;\r\n              continue;\r\n            }\r\n  \r\n            current_path = PATH.join2(current_path, parts[i]);\r\n            try {\r\n              current = FS.lookupNode(current, parts[i]);\r\n            } catch (e) {\r\n              // if noent_okay is true, suppress a ENOENT in the last component\r\n              // and return an object with an undefined node. This is needed for\r\n              // resolving symlinks in the path when creating a file.\r\n              if ((e?.errno === 44) && islast && opts.noent_okay) {\r\n                return { path: current_path };\r\n              }\r\n              throw e;\r\n            }\r\n  \r\n            // jump to the mount's root node if this is a mountpoint\r\n            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {\r\n              current = current.mounted.root;\r\n            }\r\n  \r\n            // by default, lookupPath will not follow a symlink if it is the final path component.\r\n            // setting opts.follow = true will override this behavior.\r\n            if (FS.isLink(current.mode) && (!islast || opts.follow)) {\r\n              if (!current.node_ops.readlink) {\r\n                throw new FS.ErrnoError(52);\r\n              }\r\n              var link = current.node_ops.readlink(current);\r\n              if (!PATH.isAbs(link)) {\r\n                link = PATH.dirname(current_path) + '/' + link;\r\n              }\r\n              path = link + '/' + parts.slice(i + 1).join('/');\r\n              continue linkloop;\r\n            }\r\n          }\r\n          return { path: current_path, node: current };\r\n        }\r\n        throw new FS.ErrnoError(32);\r\n      },\r\n  getPath(node) {\r\n        var path;\r\n        while (true) {\r\n          if (FS.isRoot(node)) {\r\n            var mount = node.mount.mountpoint;\r\n            if (!path) return mount;\r\n            return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;\r\n          }\r\n          path = path ? `${node.name}/${path}` : node.name;\r\n          node = node.parent;\r\n        }\r\n      },\r\n  hashName(parentid, name) {\r\n        var hash = 0;\r\n  \r\n        for (var i = 0; i < name.length; i++) {\r\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\r\n        }\r\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\r\n      },\r\n  hashAddNode(node) {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        node.name_next = FS.nameTable[hash];\r\n        FS.nameTable[hash] = node;\r\n      },\r\n  hashRemoveNode(node) {\r\n        var hash = FS.hashName(node.parent.id, node.name);\r\n        if (FS.nameTable[hash] === node) {\r\n          FS.nameTable[hash] = node.name_next;\r\n        } else {\r\n          var current = FS.nameTable[hash];\r\n          while (current) {\r\n            if (current.name_next === node) {\r\n              current.name_next = node.name_next;\r\n              break;\r\n            }\r\n            current = current.name_next;\r\n          }\r\n        }\r\n      },\r\n  lookupNode(parent, name) {\r\n        var errCode = FS.mayLookup(parent);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        var hash = FS.hashName(parent.id, name);\r\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\r\n          var nodeName = node.name;\r\n          if (node.parent.id === parent.id && nodeName === name) {\r\n            return node;\r\n          }\r\n        }\r\n        // if we failed to find it in the cache, call into the VFS\r\n        return FS.lookup(parent, name);\r\n      },\r\n  createNode(parent, name, mode, rdev) {\r\n        assert(typeof parent == 'object')\r\n        var node = new FS.FSNode(parent, name, mode, rdev);\r\n  \r\n        FS.hashAddNode(node);\r\n  \r\n        return node;\r\n      },\r\n  destroyNode(node) {\r\n        FS.hashRemoveNode(node);\r\n      },\r\n  isRoot(node) {\r\n        return node === node.parent;\r\n      },\r\n  isMountpoint(node) {\r\n        return !!node.mounted;\r\n      },\r\n  isFile(mode) {\r\n        return (mode & 61440) === 32768;\r\n      },\r\n  isDir(mode) {\r\n        return (mode & 61440) === 16384;\r\n      },\r\n  isLink(mode) {\r\n        return (mode & 61440) === 40960;\r\n      },\r\n  isChrdev(mode) {\r\n        return (mode & 61440) === 8192;\r\n      },\r\n  isBlkdev(mode) {\r\n        return (mode & 61440) === 24576;\r\n      },\r\n  isFIFO(mode) {\r\n        return (mode & 61440) === 4096;\r\n      },\r\n  isSocket(mode) {\r\n        return (mode & 49152) === 49152;\r\n      },\r\n  flagsToPermissionString(flag) {\r\n        var perms = ['r', 'w', 'rw'][flag & 3];\r\n        if ((flag & 512)) {\r\n          perms += 'w';\r\n        }\r\n        return perms;\r\n      },\r\n  nodePermissions(node, perms) {\r\n        if (FS.ignorePermissions) {\r\n          return 0;\r\n        }\r\n        // return 0 if any user, group or owner bits are set.\r\n        if (perms.includes('r') && !(node.mode & 292)) {\r\n          return 2;\r\n        } else if (perms.includes('w') && !(node.mode & 146)) {\r\n          return 2;\r\n        } else if (perms.includes('x') && !(node.mode & 73)) {\r\n          return 2;\r\n        }\r\n        return 0;\r\n      },\r\n  mayLookup(dir) {\r\n        if (!FS.isDir(dir.mode)) return 54;\r\n        var errCode = FS.nodePermissions(dir, 'x');\r\n        if (errCode) return errCode;\r\n        if (!dir.node_ops.lookup) return 2;\r\n        return 0;\r\n      },\r\n  mayCreate(dir, name) {\r\n        if (!FS.isDir(dir.mode)) {\r\n          return 54;\r\n        }\r\n        try {\r\n          var node = FS.lookupNode(dir, name);\r\n          return 20;\r\n        } catch (e) {\r\n        }\r\n        return FS.nodePermissions(dir, 'wx');\r\n      },\r\n  mayDelete(dir, name, isdir) {\r\n        var node;\r\n        try {\r\n          node = FS.lookupNode(dir, name);\r\n        } catch (e) {\r\n          return e.errno;\r\n        }\r\n        var errCode = FS.nodePermissions(dir, 'wx');\r\n        if (errCode) {\r\n          return errCode;\r\n        }\r\n        if (isdir) {\r\n          if (!FS.isDir(node.mode)) {\r\n            return 54;\r\n          }\r\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\r\n            return 10;\r\n          }\r\n        } else {\r\n          if (FS.isDir(node.mode)) {\r\n            return 31;\r\n          }\r\n        }\r\n        return 0;\r\n      },\r\n  mayOpen(node, flags) {\r\n        if (!node) {\r\n          return 44;\r\n        }\r\n        if (FS.isLink(node.mode)) {\r\n          return 32;\r\n        } else if (FS.isDir(node.mode)) {\r\n          if (FS.flagsToPermissionString(flags) !== 'r' // opening for write\r\n              || (flags & (512 | 64))) { // TODO: check for O_SEARCH? (== search for dir only)\r\n            return 31;\r\n          }\r\n        }\r\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\r\n      },\r\n  checkOpExists(op, err) {\r\n        if (!op) {\r\n          throw new FS.ErrnoError(err);\r\n        }\r\n        return op;\r\n      },\r\n  MAX_OPEN_FDS:4096,\r\n  nextfd() {\r\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\r\n          if (!FS.streams[fd]) {\r\n            return fd;\r\n          }\r\n        }\r\n        throw new FS.ErrnoError(33);\r\n      },\r\n  getStreamChecked(fd) {\r\n        var stream = FS.getStream(fd);\r\n        if (!stream) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        return stream;\r\n      },\r\n  getStream:(fd) => FS.streams[fd],\r\n  createStream(stream, fd = -1) {\r\n        assert(fd >= -1);\r\n  \r\n        // clone it, so we can return an instance of FSStream\r\n        stream = Object.assign(new FS.FSStream(), stream);\r\n        if (fd == -1) {\r\n          fd = FS.nextfd();\r\n        }\r\n        stream.fd = fd;\r\n        FS.streams[fd] = stream;\r\n        return stream;\r\n      },\r\n  closeStream(fd) {\r\n        FS.streams[fd] = null;\r\n      },\r\n  dupStream(origStream, fd = -1) {\r\n        var stream = FS.createStream(origStream, fd);\r\n        stream.stream_ops?.dup?.(stream);\r\n        return stream;\r\n      },\r\n  chrdev_stream_ops:{\r\n  open(stream) {\r\n          var device = FS.getDevice(stream.node.rdev);\r\n          // override node's stream ops with the device's\r\n          stream.stream_ops = device.stream_ops;\r\n          // forward the open call\r\n          stream.stream_ops.open?.(stream);\r\n        },\r\n  llseek() {\r\n          throw new FS.ErrnoError(70);\r\n        },\r\n  },\r\n  major:(dev) => ((dev) >> 8),\r\n  minor:(dev) => ((dev) & 0xff),\r\n  makedev:(ma, mi) => ((ma) << 8 | (mi)),\r\n  registerDevice(dev, ops) {\r\n        FS.devices[dev] = { stream_ops: ops };\r\n      },\r\n  getDevice:(dev) => FS.devices[dev],\r\n  getMounts(mount) {\r\n        var mounts = [];\r\n        var check = [mount];\r\n  \r\n        while (check.length) {\r\n          var m = check.pop();\r\n  \r\n          mounts.push(m);\r\n  \r\n          check.push(...m.mounts);\r\n        }\r\n  \r\n        return mounts;\r\n      },\r\n  syncfs(populate, callback) {\r\n        if (typeof populate == 'function') {\r\n          callback = populate;\r\n          populate = false;\r\n        }\r\n  \r\n        FS.syncFSRequests++;\r\n  \r\n        if (FS.syncFSRequests > 1) {\r\n          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\r\n        }\r\n  \r\n        var mounts = FS.getMounts(FS.root.mount);\r\n        var completed = 0;\r\n  \r\n        function doCallback(errCode) {\r\n          assert(FS.syncFSRequests > 0);\r\n          FS.syncFSRequests--;\r\n          return callback(errCode);\r\n        }\r\n  \r\n        function done(errCode) {\r\n          if (errCode) {\r\n            if (!done.errored) {\r\n              done.errored = true;\r\n              return doCallback(errCode);\r\n            }\r\n            return;\r\n          }\r\n          if (++completed >= mounts.length) {\r\n            doCallback(null);\r\n          }\r\n        };\r\n  \r\n        // sync all mounts\r\n        mounts.forEach((mount) => {\r\n          if (!mount.type.syncfs) {\r\n            return done(null);\r\n          }\r\n          mount.type.syncfs(mount, populate, done);\r\n        });\r\n      },\r\n  mount(type, opts, mountpoint) {\r\n        if (typeof type == 'string') {\r\n          // The filesystem was not included, and instead we have an error\r\n          // message stored in the variable.\r\n          throw type;\r\n        }\r\n        var root = mountpoint === '/';\r\n        var pseudo = !mountpoint;\r\n        var node;\r\n  \r\n        if (root && FS.root) {\r\n          throw new FS.ErrnoError(10);\r\n        } else if (!root && !pseudo) {\r\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n          mountpoint = lookup.path;  // use the absolute path\r\n          node = lookup.node;\r\n  \r\n          if (FS.isMountpoint(node)) {\r\n            throw new FS.ErrnoError(10);\r\n          }\r\n  \r\n          if (!FS.isDir(node.mode)) {\r\n            throw new FS.ErrnoError(54);\r\n          }\r\n        }\r\n  \r\n        var mount = {\r\n          type,\r\n          opts,\r\n          mountpoint,\r\n          mounts: []\r\n        };\r\n  \r\n        // create a root node for the fs\r\n        var mountRoot = type.mount(mount);\r\n        mountRoot.mount = mount;\r\n        mount.root = mountRoot;\r\n  \r\n        if (root) {\r\n          FS.root = mountRoot;\r\n        } else if (node) {\r\n          // set as a mountpoint\r\n          node.mounted = mount;\r\n  \r\n          // add the new mount to the current mount's children\r\n          if (node.mount) {\r\n            node.mount.mounts.push(mount);\r\n          }\r\n        }\r\n  \r\n        return mountRoot;\r\n      },\r\n  unmount(mountpoint) {\r\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\r\n  \r\n        if (!FS.isMountpoint(lookup.node)) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n  \r\n        // destroy the nodes for this mount, and all its child mounts\r\n        var node = lookup.node;\r\n        var mount = node.mounted;\r\n        var mounts = FS.getMounts(mount);\r\n  \r\n        Object.keys(FS.nameTable).forEach((hash) => {\r\n          var current = FS.nameTable[hash];\r\n  \r\n          while (current) {\r\n            var next = current.name_next;\r\n  \r\n            if (mounts.includes(current.mount)) {\r\n              FS.destroyNode(current);\r\n            }\r\n  \r\n            current = next;\r\n          }\r\n        });\r\n  \r\n        // no longer a mountpoint\r\n        node.mounted = null;\r\n  \r\n        // remove this mount from the child mounts\r\n        var idx = node.mount.mounts.indexOf(mount);\r\n        assert(idx !== -1);\r\n        node.mount.mounts.splice(idx, 1);\r\n      },\r\n  lookup(parent, name) {\r\n        return parent.node_ops.lookup(parent, name);\r\n      },\r\n  mknod(path, mode, dev) {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        if (!name) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (name === '.' || name === '..') {\r\n          throw new FS.ErrnoError(20);\r\n        }\r\n        var errCode = FS.mayCreate(parent, name);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.mknod) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return parent.node_ops.mknod(parent, name, mode, dev);\r\n      },\r\n  statfs(path) {\r\n        return FS.statfsNode(FS.lookupPath(path, {follow: true}).node);\r\n      },\r\n  statfsStream(stream) {\r\n        // We keep a separate statfsStream function because noderawfs overrides\r\n        // it. In noderawfs, stream.node is sometimes null. Instead, we need to\r\n        // look at stream.path.\r\n        return FS.statfsNode(stream.node);\r\n      },\r\n  statfsNode(node) {\r\n        // NOTE: None of the defaults here are true. We're just returning safe and\r\n        //       sane values. Currently nodefs and rawfs replace these defaults,\r\n        //       other file systems leave them alone.\r\n        var rtn = {\r\n          bsize: 4096,\r\n          frsize: 4096,\r\n          blocks: 1e6,\r\n          bfree: 5e5,\r\n          bavail: 5e5,\r\n          files: FS.nextInode,\r\n          ffree: FS.nextInode - 1,\r\n          fsid: 42,\r\n          flags: 2,\r\n          namelen: 255,\r\n        };\r\n  \r\n        if (node.node_ops.statfs) {\r\n          Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));\r\n        }\r\n        return rtn;\r\n      },\r\n  create(path, mode = 0o666) {\r\n        mode &= 4095;\r\n        mode |= 32768;\r\n        return FS.mknod(path, mode, 0);\r\n      },\r\n  mkdir(path, mode = 0o777) {\r\n        mode &= 511 | 512;\r\n        mode |= 16384;\r\n        return FS.mknod(path, mode, 0);\r\n      },\r\n  mkdirTree(path, mode) {\r\n        var dirs = path.split('/');\r\n        var d = '';\r\n        for (var i = 0; i < dirs.length; ++i) {\r\n          if (!dirs[i]) continue;\r\n          d += '/' + dirs[i];\r\n          try {\r\n            FS.mkdir(d, mode);\r\n          } catch(e) {\r\n            if (e.errno != 20) throw e;\r\n          }\r\n        }\r\n      },\r\n  mkdev(path, mode, dev) {\r\n        if (typeof dev == 'undefined') {\r\n          dev = mode;\r\n          mode = 0o666;\r\n        }\r\n        mode |= 8192;\r\n        return FS.mknod(path, mode, dev);\r\n      },\r\n  symlink(oldpath, newpath) {\r\n        if (!PATH_FS.resolve(oldpath)) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var lookup = FS.lookupPath(newpath, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var newname = PATH.basename(newpath);\r\n        var errCode = FS.mayCreate(parent, newname);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.symlink) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        return parent.node_ops.symlink(parent, newname, oldpath);\r\n      },\r\n  rename(old_path, new_path) {\r\n        var old_dirname = PATH.dirname(old_path);\r\n        var new_dirname = PATH.dirname(new_path);\r\n        var old_name = PATH.basename(old_path);\r\n        var new_name = PATH.basename(new_path);\r\n        // parents must exist\r\n        var lookup, old_dir, new_dir;\r\n  \r\n        // let the errors from non existent directories percolate up\r\n        lookup = FS.lookupPath(old_path, { parent: true });\r\n        old_dir = lookup.node;\r\n        lookup = FS.lookupPath(new_path, { parent: true });\r\n        new_dir = lookup.node;\r\n  \r\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\r\n        // need to be part of the same mount\r\n        if (old_dir.mount !== new_dir.mount) {\r\n          throw new FS.ErrnoError(75);\r\n        }\r\n        // source must exist\r\n        var old_node = FS.lookupNode(old_dir, old_name);\r\n        // old path should not be an ancestor of the new path\r\n        var relative = PATH_FS.relative(old_path, new_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        // new path should not be an ancestor of the old path\r\n        relative = PATH_FS.relative(new_path, old_dirname);\r\n        if (relative.charAt(0) !== '.') {\r\n          throw new FS.ErrnoError(55);\r\n        }\r\n        // see if the new path already exists\r\n        var new_node;\r\n        try {\r\n          new_node = FS.lookupNode(new_dir, new_name);\r\n        } catch (e) {\r\n          // not fatal\r\n        }\r\n        // early out if nothing needs to change\r\n        if (old_node === new_node) {\r\n          return;\r\n        }\r\n        // we'll need to delete the old entry\r\n        var isdir = FS.isDir(old_node.mode);\r\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        // need delete permissions if we'll be overwriting.\r\n        // need create permissions if new doesn't already exist.\r\n        errCode = new_node ?\r\n          FS.mayDelete(new_dir, new_name, isdir) :\r\n          FS.mayCreate(new_dir, new_name);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!old_dir.node_ops.rename) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        // if we are going to change the parent, check write permissions\r\n        if (new_dir !== old_dir) {\r\n          errCode = FS.nodePermissions(old_dir, 'w');\r\n          if (errCode) {\r\n            throw new FS.ErrnoError(errCode);\r\n          }\r\n        }\r\n        // remove the node from the lookup hash\r\n        FS.hashRemoveNode(old_node);\r\n        // do the underlying fs rename\r\n        try {\r\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\r\n          // update old node (we do this here to avoid each backend\r\n          // needing to)\r\n          old_node.parent = new_dir;\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          // add the node back to the hash (in case node_ops.rename\r\n          // changed its name)\r\n          FS.hashAddNode(old_node);\r\n        }\r\n      },\r\n  rmdir(path) {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var errCode = FS.mayDelete(parent, name, true);\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.rmdir) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        parent.node_ops.rmdir(parent, name);\r\n        FS.destroyNode(node);\r\n      },\r\n  readdir(path) {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        var readdir = FS.checkOpExists(node.node_ops.readdir, 54);\r\n        return readdir(node);\r\n      },\r\n  unlink(path) {\r\n        var lookup = FS.lookupPath(path, { parent: true });\r\n        var parent = lookup.node;\r\n        if (!parent) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        var name = PATH.basename(path);\r\n        var node = FS.lookupNode(parent, name);\r\n        var errCode = FS.mayDelete(parent, name, false);\r\n        if (errCode) {\r\n          // According to POSIX, we should map EISDIR to EPERM, but\r\n          // we instead do what Linux does (and we must, as we use\r\n          // the musl linux libc).\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        if (!parent.node_ops.unlink) {\r\n          throw new FS.ErrnoError(63);\r\n        }\r\n        if (FS.isMountpoint(node)) {\r\n          throw new FS.ErrnoError(10);\r\n        }\r\n        parent.node_ops.unlink(parent, name);\r\n        FS.destroyNode(node);\r\n      },\r\n  readlink(path) {\r\n        var lookup = FS.lookupPath(path);\r\n        var link = lookup.node;\r\n        if (!link) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!link.node_ops.readlink) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        return link.node_ops.readlink(link);\r\n      },\r\n  stat(path, dontFollow) {\r\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n        var node = lookup.node;\r\n        var getattr = FS.checkOpExists(node.node_ops.getattr, 63);\r\n        return getattr(node);\r\n      },\r\n  lstat(path) {\r\n        return FS.stat(path, true);\r\n      },\r\n  chmod(path, mode, dontFollow) {\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\r\n        setattr(node, {\r\n          mode: (mode & 4095) | (node.mode & ~4095),\r\n          ctime: Date.now(),\r\n          dontFollow\r\n        });\r\n      },\r\n  lchmod(path, mode) {\r\n        FS.chmod(path, mode, true);\r\n      },\r\n  fchmod(fd, mode) {\r\n        var stream = FS.getStreamChecked(fd);\r\n        FS.chmod(stream.node, mode);\r\n      },\r\n  chown(path, uid, gid, dontFollow) {\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\r\n        setattr(node, {\r\n          timestamp: Date.now(),\r\n          dontFollow\r\n          // we ignore the uid / gid for now\r\n        });\r\n      },\r\n  lchown(path, uid, gid) {\r\n        FS.chown(path, uid, gid, true);\r\n      },\r\n  fchown(fd, uid, gid) {\r\n        var stream = FS.getStreamChecked(fd);\r\n        FS.chown(stream.node, uid, gid);\r\n      },\r\n  truncate(path, len) {\r\n        if (len < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var node;\r\n        if (typeof path == 'string') {\r\n          var lookup = FS.lookupPath(path, { follow: true });\r\n          node = lookup.node;\r\n        } else {\r\n          node = path;\r\n        }\r\n        if (FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!FS.isFile(node.mode)) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var errCode = FS.nodePermissions(node, 'w');\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\r\n        setattr(node, {\r\n          size: len,\r\n          timestamp: Date.now()\r\n        });\r\n      },\r\n  ftruncate(fd, len) {\r\n        var stream = FS.getStreamChecked(fd);\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        FS.truncate(stream.node, len);\r\n      },\r\n  utime(path, atime, mtime) {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        var node = lookup.node;\r\n        var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\r\n        setattr(node, {\r\n          atime: atime,\r\n          mtime: mtime\r\n        });\r\n      },\r\n  open(path, flags, mode = 0o666) {\r\n        if (path === \"\") {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\r\n        if ((flags & 64)) {\r\n          mode = (mode & 4095) | 32768;\r\n        } else {\r\n          mode = 0;\r\n        }\r\n        var node;\r\n        var isDirPath;\r\n        if (typeof path == 'object') {\r\n          node = path;\r\n        } else {\r\n          isDirPath = path.endsWith(\"/\");\r\n          // noent_okay makes it so that if the final component of the path\r\n          // doesn't exist, lookupPath returns `node: undefined`. `path` will be\r\n          // updated to point to the target of all symlinks.\r\n          var lookup = FS.lookupPath(path, {\r\n            follow: !(flags & 131072),\r\n            noent_okay: true\r\n          });\r\n          node = lookup.node;\r\n          path = lookup.path;\r\n        }\r\n        // perhaps we need to create the node\r\n        var created = false;\r\n        if ((flags & 64)) {\r\n          if (node) {\r\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\r\n            if ((flags & 128)) {\r\n              throw new FS.ErrnoError(20);\r\n            }\r\n          } else if (isDirPath) {\r\n            throw new FS.ErrnoError(31);\r\n          } else {\r\n            // node doesn't exist, try to create it\r\n            // Ignore the permission bits here to ensure we can `open` this new\r\n            // file below. We use chmod below the apply the permissions once the\r\n            // file is open.\r\n            node = FS.mknod(path, mode | 0o777, 0);\r\n            created = true;\r\n          }\r\n        }\r\n        if (!node) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        // can't truncate a device\r\n        if (FS.isChrdev(node.mode)) {\r\n          flags &= ~512;\r\n        }\r\n        // if asked only for a directory, then this must be one\r\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        // check permissions, if this is not a file we just created now (it is ok to\r\n        // create and write to a file with read-only permissions; it is read-only\r\n        // for later use)\r\n        if (!created) {\r\n          var errCode = FS.mayOpen(node, flags);\r\n          if (errCode) {\r\n            throw new FS.ErrnoError(errCode);\r\n          }\r\n        }\r\n        // do truncation if necessary\r\n        if ((flags & 512) && !created) {\r\n          FS.truncate(node, 0);\r\n        }\r\n        // we've already handled these, don't pass down to the underlying vfs\r\n        flags &= ~(128 | 512 | 131072);\r\n  \r\n        // register the stream with the filesystem\r\n        var stream = FS.createStream({\r\n          node,\r\n          path: FS.getPath(node),  // we want the absolute path to the node\r\n          flags,\r\n          seekable: true,\r\n          position: 0,\r\n          stream_ops: node.stream_ops,\r\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\r\n          ungotten: [],\r\n          error: false\r\n        });\r\n        // call the new stream's open function\r\n        if (stream.stream_ops.open) {\r\n          stream.stream_ops.open(stream);\r\n        }\r\n        if (created) {\r\n          FS.chmod(node, mode & 0o777);\r\n        }\r\n        if (Module['logReadFiles'] && !(flags & 1)) {\r\n          if (!(path in FS.readFiles)) {\r\n            FS.readFiles[path] = 1;\r\n          }\r\n        }\r\n        return stream;\r\n      },\r\n  close(stream) {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (stream.getdents) stream.getdents = null; // free readdir state\r\n        try {\r\n          if (stream.stream_ops.close) {\r\n            stream.stream_ops.close(stream);\r\n          }\r\n        } catch (e) {\r\n          throw e;\r\n        } finally {\r\n          FS.closeStream(stream.fd);\r\n        }\r\n        stream.fd = null;\r\n      },\r\n  isClosed(stream) {\r\n        return stream.fd === null;\r\n      },\r\n  llseek(stream, offset, whence) {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (!stream.seekable || !stream.stream_ops.llseek) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        if (whence != 0 && whence != 1 && whence != 2) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\r\n        stream.ungotten = [];\r\n        return stream.position;\r\n      },\r\n  read(stream, buffer, offset, length, position) {\r\n        assert(offset >= 0);\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!stream.stream_ops.read) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        var seeking = typeof position != 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\r\n        if (!seeking) stream.position += bytesRead;\r\n        return bytesRead;\r\n      },\r\n  write(stream, buffer, offset, length, position, canOwn) {\r\n        assert(offset >= 0);\r\n        if (length < 0 || position < 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(31);\r\n        }\r\n        if (!stream.stream_ops.write) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if (stream.seekable && stream.flags & 1024) {\r\n          // seek to the end before writing in append mode\r\n          FS.llseek(stream, 0, 2);\r\n        }\r\n        var seeking = typeof position != 'undefined';\r\n        if (!seeking) {\r\n          position = stream.position;\r\n        } else if (!stream.seekable) {\r\n          throw new FS.ErrnoError(70);\r\n        }\r\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\r\n        if (!seeking) stream.position += bytesWritten;\r\n        return bytesWritten;\r\n      },\r\n  allocate(stream, offset, length) {\r\n        if (FS.isClosed(stream)) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (offset < 0 || length <= 0) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        if ((stream.flags & 2097155) === 0) {\r\n          throw new FS.ErrnoError(8);\r\n        }\r\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        if (!stream.stream_ops.allocate) {\r\n          throw new FS.ErrnoError(138);\r\n        }\r\n        stream.stream_ops.allocate(stream, offset, length);\r\n      },\r\n  mmap(stream, length, position, prot, flags) {\r\n        // User requests writing to file (prot & PROT_WRITE != 0).\r\n        // Checking if we have permissions to write to the file unless\r\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\r\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\r\n        // as all modifications will be visible only in the memory of\r\n        // the current process.\r\n        if ((prot & 2) !== 0\r\n            && (flags & 2) === 0\r\n            && (stream.flags & 2097155) !== 2) {\r\n          throw new FS.ErrnoError(2);\r\n        }\r\n        if ((stream.flags & 2097155) === 1) {\r\n          throw new FS.ErrnoError(2);\r\n        }\r\n        if (!stream.stream_ops.mmap) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        if (!length) {\r\n          throw new FS.ErrnoError(28);\r\n        }\r\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\r\n      },\r\n  msync(stream, buffer, offset, length, mmapFlags) {\r\n        assert(offset >= 0);\r\n        if (!stream.stream_ops.msync) {\r\n          return 0;\r\n        }\r\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\r\n      },\r\n  ioctl(stream, cmd, arg) {\r\n        if (!stream.stream_ops.ioctl) {\r\n          throw new FS.ErrnoError(59);\r\n        }\r\n        return stream.stream_ops.ioctl(stream, cmd, arg);\r\n      },\r\n  readFile(path, opts = {}) {\r\n        opts.flags = opts.flags || 0;\r\n        opts.encoding = opts.encoding || 'binary';\r\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\r\n          throw new Error(`Invalid encoding type \"${opts.encoding}\"`);\r\n        }\r\n        var ret;\r\n        var stream = FS.open(path, opts.flags);\r\n        var stat = FS.stat(path);\r\n        var length = stat.size;\r\n        var buf = new Uint8Array(length);\r\n        FS.read(stream, buf, 0, length, 0);\r\n        if (opts.encoding === 'utf8') {\r\n          ret = UTF8ArrayToString(buf);\r\n        } else if (opts.encoding === 'binary') {\r\n          ret = buf;\r\n        }\r\n        FS.close(stream);\r\n        return ret;\r\n      },\r\n  writeFile(path, data, opts = {}) {\r\n        opts.flags = opts.flags || 577;\r\n        var stream = FS.open(path, opts.flags, opts.mode);\r\n        if (typeof data == 'string') {\r\n          var buf = new Uint8Array(lengthBytesUTF8(data)+1);\r\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\r\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\r\n        } else if (ArrayBuffer.isView(data)) {\r\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\r\n        } else {\r\n          throw new Error('Unsupported data type');\r\n        }\r\n        FS.close(stream);\r\n      },\r\n  cwd:() => FS.currentPath,\r\n  chdir(path) {\r\n        var lookup = FS.lookupPath(path, { follow: true });\r\n        if (lookup.node === null) {\r\n          throw new FS.ErrnoError(44);\r\n        }\r\n        if (!FS.isDir(lookup.node.mode)) {\r\n          throw new FS.ErrnoError(54);\r\n        }\r\n        var errCode = FS.nodePermissions(lookup.node, 'x');\r\n        if (errCode) {\r\n          throw new FS.ErrnoError(errCode);\r\n        }\r\n        FS.currentPath = lookup.path;\r\n      },\r\n  createDefaultDirectories() {\r\n        FS.mkdir('/tmp');\r\n        FS.mkdir('/home');\r\n        FS.mkdir('/home/web_user');\r\n      },\r\n  createDefaultDevices() {\r\n        // create /dev\r\n        FS.mkdir('/dev');\r\n        // setup /dev/null\r\n        FS.registerDevice(FS.makedev(1, 3), {\r\n          read: () => 0,\r\n          write: (stream, buffer, offset, length, pos) => length,\r\n          llseek: () => 0,\r\n        });\r\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\r\n        // setup /dev/tty and /dev/tty1\r\n        // stderr needs to print output using err() rather than out()\r\n        // so we register a second tty just for it.\r\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\r\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\r\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\r\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\r\n        // setup /dev/[u]random\r\n        // use a buffer to avoid overhead of individual crypto calls per byte\r\n        var randomBuffer = new Uint8Array(1024), randomLeft = 0;\r\n        var randomByte = () => {\r\n          if (randomLeft === 0) {\r\n            randomFill(randomBuffer);\r\n            randomLeft = randomBuffer.byteLength;\r\n          }\r\n          return randomBuffer[--randomLeft];\r\n        };\r\n        FS.createDevice('/dev', 'random', randomByte);\r\n        FS.createDevice('/dev', 'urandom', randomByte);\r\n        // we're not going to emulate the actual shm device,\r\n        // just create the tmp dirs that reside in it commonly\r\n        FS.mkdir('/dev/shm');\r\n        FS.mkdir('/dev/shm/tmp');\r\n      },\r\n  createSpecialDirectories() {\r\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\r\n        // name of the stream for fd 6 (see test_unistd_ttyname)\r\n        FS.mkdir('/proc');\r\n        var proc_self = FS.mkdir('/proc/self');\r\n        FS.mkdir('/proc/self/fd');\r\n        FS.mount({\r\n          mount() {\r\n            var node = FS.createNode(proc_self, 'fd', 16895, 73);\r\n            node.stream_ops = {\r\n              llseek: MEMFS.stream_ops.llseek,\r\n            };\r\n            node.node_ops = {\r\n              lookup(parent, name) {\r\n                var fd = +name;\r\n                var stream = FS.getStreamChecked(fd);\r\n                var ret = {\r\n                  parent: null,\r\n                  mount: { mountpoint: 'fake' },\r\n                  node_ops: { readlink: () => stream.path },\r\n                  id: fd + 1,\r\n                };\r\n                ret.parent = ret; // make it look like a simple root node\r\n                return ret;\r\n              },\r\n              readdir() {\r\n                return Array.from(FS.streams.entries())\r\n                  .filter(([k, v]) => v)\r\n                  .map(([k, v]) => k.toString());\r\n              }\r\n            };\r\n            return node;\r\n          }\r\n        }, {}, '/proc/self/fd');\r\n      },\r\n  createStandardStreams(input, output, error) {\r\n        // TODO deprecate the old functionality of a single\r\n        // input / output callback and that utilizes FS.createDevice\r\n        // and instead require a unique set of stream ops\r\n  \r\n        // by default, we symlink the standard streams to the\r\n        // default tty devices. however, if the standard streams\r\n        // have been overwritten we create a unique device for\r\n        // them instead.\r\n        if (input) {\r\n          FS.createDevice('/dev', 'stdin', input);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdin');\r\n        }\r\n        if (output) {\r\n          FS.createDevice('/dev', 'stdout', null, output);\r\n        } else {\r\n          FS.symlink('/dev/tty', '/dev/stdout');\r\n        }\r\n        if (error) {\r\n          FS.createDevice('/dev', 'stderr', null, error);\r\n        } else {\r\n          FS.symlink('/dev/tty1', '/dev/stderr');\r\n        }\r\n  \r\n        // open default streams for the stdin, stdout and stderr devices\r\n        var stdin = FS.open('/dev/stdin', 0);\r\n        var stdout = FS.open('/dev/stdout', 1);\r\n        var stderr = FS.open('/dev/stderr', 1);\r\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\r\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\r\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\r\n      },\r\n  staticInit() {\r\n        FS.nameTable = new Array(4096);\r\n  \r\n        FS.mount(MEMFS, {}, '/');\r\n  \r\n        FS.createDefaultDirectories();\r\n        FS.createDefaultDevices();\r\n        FS.createSpecialDirectories();\r\n  \r\n        FS.filesystems = {\r\n          'MEMFS': MEMFS,\r\n        };\r\n      },\r\n  init(input, output, error) {\r\n        assert(!FS.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\r\n        FS.initialized = true;\r\n  \r\n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\r\n        input ??= Module['stdin'];\r\n        output ??= Module['stdout'];\r\n        error ??= Module['stderr'];\r\n  \r\n        FS.createStandardStreams(input, output, error);\r\n      },\r\n  quit() {\r\n        FS.initialized = false;\r\n        // force-flush all streams, so we get musl std streams printed out\r\n        _fflush(0);\r\n        // close all of our streams\r\n        for (var i = 0; i < FS.streams.length; i++) {\r\n          var stream = FS.streams[i];\r\n          if (!stream) {\r\n            continue;\r\n          }\r\n          FS.close(stream);\r\n        }\r\n      },\r\n  findObject(path, dontResolveLastLink) {\r\n        var ret = FS.analyzePath(path, dontResolveLastLink);\r\n        if (!ret.exists) {\r\n          return null;\r\n        }\r\n        return ret.object;\r\n      },\r\n  analyzePath(path, dontResolveLastLink) {\r\n        // operate from within the context of the symlink's target\r\n        try {\r\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          path = lookup.path;\r\n        } catch (e) {\r\n        }\r\n        var ret = {\r\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\r\n          parentExists: false, parentPath: null, parentObject: null\r\n        };\r\n        try {\r\n          var lookup = FS.lookupPath(path, { parent: true });\r\n          ret.parentExists = true;\r\n          ret.parentPath = lookup.path;\r\n          ret.parentObject = lookup.node;\r\n          ret.name = PATH.basename(path);\r\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\r\n          ret.exists = true;\r\n          ret.path = lookup.path;\r\n          ret.object = lookup.node;\r\n          ret.name = lookup.node.name;\r\n          ret.isRoot = lookup.path === '/';\r\n        } catch (e) {\r\n          ret.error = e.errno;\r\n        };\r\n        return ret;\r\n      },\r\n  createPath(parent, path, canRead, canWrite) {\r\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n        var parts = path.split('/').reverse();\r\n        while (parts.length) {\r\n          var part = parts.pop();\r\n          if (!part) continue;\r\n          var current = PATH.join2(parent, part);\r\n          try {\r\n            FS.mkdir(current);\r\n          } catch (e) {\r\n            // ignore EEXIST\r\n          }\r\n          parent = current;\r\n        }\r\n        return current;\r\n      },\r\n  createFile(parent, name, properties, canRead, canWrite) {\r\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS_getMode(canRead, canWrite);\r\n        return FS.create(path, mode);\r\n      },\r\n  createDataFile(parent, name, data, canRead, canWrite, canOwn) {\r\n        var path = name;\r\n        if (parent) {\r\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\r\n          path = name ? PATH.join2(parent, name) : parent;\r\n        }\r\n        var mode = FS_getMode(canRead, canWrite);\r\n        var node = FS.create(path, mode);\r\n        if (data) {\r\n          if (typeof data == 'string') {\r\n            var arr = new Array(data.length);\r\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\r\n            data = arr;\r\n          }\r\n          // make sure we can write to the file\r\n          FS.chmod(node, mode | 146);\r\n          var stream = FS.open(node, 577);\r\n          FS.write(stream, data, 0, data.length, 0, canOwn);\r\n          FS.close(stream);\r\n          FS.chmod(node, mode);\r\n        }\r\n      },\r\n  createDevice(parent, name, input, output) {\r\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\r\n        var mode = FS_getMode(!!input, !!output);\r\n        FS.createDevice.major ??= 64;\r\n        var dev = FS.makedev(FS.createDevice.major++, 0);\r\n        // Create a fake device that a set of stream ops to emulate\r\n        // the old behavior.\r\n        FS.registerDevice(dev, {\r\n          open(stream) {\r\n            stream.seekable = false;\r\n          },\r\n          close(stream) {\r\n            // flush any pending line data\r\n            if (output?.buffer?.length) {\r\n              output(10);\r\n            }\r\n          },\r\n          read(stream, buffer, offset, length, pos /* ignored */) {\r\n            var bytesRead = 0;\r\n            for (var i = 0; i < length; i++) {\r\n              var result;\r\n              try {\r\n                result = input();\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(29);\r\n              }\r\n              if (result === undefined && bytesRead === 0) {\r\n                throw new FS.ErrnoError(6);\r\n              }\r\n              if (result === null || result === undefined) break;\r\n              bytesRead++;\r\n              buffer[offset+i] = result;\r\n            }\r\n            if (bytesRead) {\r\n              stream.node.atime = Date.now();\r\n            }\r\n            return bytesRead;\r\n          },\r\n          write(stream, buffer, offset, length, pos) {\r\n            for (var i = 0; i < length; i++) {\r\n              try {\r\n                output(buffer[offset+i]);\r\n              } catch (e) {\r\n                throw new FS.ErrnoError(29);\r\n              }\r\n            }\r\n            if (length) {\r\n              stream.node.mtime = stream.node.ctime = Date.now();\r\n            }\r\n            return i;\r\n          }\r\n        });\r\n        return FS.mkdev(path, mode, dev);\r\n      },\r\n  forceLoadFile(obj) {\r\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\r\n        if (typeof XMLHttpRequest != 'undefined') {\r\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\r\n        } else { // Command-line.\r\n          try {\r\n            obj.contents = readBinary(obj.url);\r\n            obj.usedBytes = obj.contents.length;\r\n          } catch (e) {\r\n            throw new FS.ErrnoError(29);\r\n          }\r\n        }\r\n      },\r\n  createLazyFile(parent, name, url, canRead, canWrite) {\r\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array).\r\n        // Actual getting is abstracted away for eventual reuse.\r\n        class LazyUint8Array {\r\n          lengthKnown = false;\r\n          chunks = []; // Loaded chunks. Index is the chunk number\r\n          get(idx) {\r\n            if (idx > this.length-1 || idx < 0) {\r\n              return undefined;\r\n            }\r\n            var chunkOffset = idx % this.chunkSize;\r\n            var chunkNum = (idx / this.chunkSize)|0;\r\n            return this.getter(chunkNum)[chunkOffset];\r\n          }\r\n          setDataGetter(getter) {\r\n            this.getter = getter;\r\n          }\r\n          cacheLength() {\r\n            // Find length\r\n            var xhr = new XMLHttpRequest();\r\n            xhr.open('HEAD', url, false);\r\n            xhr.send(null);\r\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n            var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\r\n            var header;\r\n            var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\r\n            var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\r\n  \r\n            var chunkSize = 1024*1024; // Chunk size in bytes\r\n  \r\n            if (!hasByteServing) chunkSize = datalength;\r\n  \r\n            // Function to get a range from the remote URL.\r\n            var doXHR = (from, to) => {\r\n              if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\r\n              if (to > datalength-1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\r\n  \r\n              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\r\n              var xhr = new XMLHttpRequest();\r\n              xhr.open('GET', url, false);\r\n              if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\r\n  \r\n              // Some hints to the browser that we want binary data.\r\n              xhr.responseType = 'arraybuffer';\r\n              if (xhr.overrideMimeType) {\r\n                xhr.overrideMimeType('text/plain; charset=x-user-defined');\r\n              }\r\n  \r\n              xhr.send(null);\r\n              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\r\n              if (xhr.response !== undefined) {\r\n                return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));\r\n              }\r\n              return intArrayFromString(xhr.responseText || '', true);\r\n            };\r\n            var lazyArray = this;\r\n            lazyArray.setDataGetter((chunkNum) => {\r\n              var start = chunkNum * chunkSize;\r\n              var end = (chunkNum+1) * chunkSize - 1; // including this byte\r\n              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\r\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\r\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\r\n              }\r\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');\r\n              return lazyArray.chunks[chunkNum];\r\n            });\r\n  \r\n            if (usesGzip || !datalength) {\r\n              // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\r\n              chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\r\n              datalength = this.getter(0).length;\r\n              chunkSize = datalength;\r\n              out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\r\n            }\r\n  \r\n            this._length = datalength;\r\n            this._chunkSize = chunkSize;\r\n            this.lengthKnown = true;\r\n          }\r\n          get length() {\r\n            if (!this.lengthKnown) {\r\n              this.cacheLength();\r\n            }\r\n            return this._length;\r\n          }\r\n          get chunkSize() {\r\n            if (!this.lengthKnown) {\r\n              this.cacheLength();\r\n            }\r\n            return this._chunkSize;\r\n          }\r\n        }\r\n  \r\n        if (typeof XMLHttpRequest != 'undefined') {\r\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\r\n          var lazyArray = new LazyUint8Array();\r\n          var properties = { isDevice: false, contents: lazyArray };\r\n        } else {\r\n          var properties = { isDevice: false, url: url };\r\n        }\r\n  \r\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\r\n        // This is a total hack, but I want to get this lazy file code out of the\r\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\r\n        // be its own thin LAZYFS proxying calls to MEMFS.\r\n        if (properties.contents) {\r\n          node.contents = properties.contents;\r\n        } else if (properties.url) {\r\n          node.contents = null;\r\n          node.url = properties.url;\r\n        }\r\n        // Add a function that defers querying the file size until it is asked the first time.\r\n        Object.defineProperties(node, {\r\n          usedBytes: {\r\n            get: function() { return this.contents.length; }\r\n          }\r\n        });\r\n        // override each stream op with one that tries to force load the lazy file first\r\n        var stream_ops = {};\r\n        var keys = Object.keys(node.stream_ops);\r\n        keys.forEach((key) => {\r\n          var fn = node.stream_ops[key];\r\n          stream_ops[key] = (...args) => {\r\n            FS.forceLoadFile(node);\r\n            return fn(...args);\r\n          };\r\n        });\r\n        function writeChunks(stream, buffer, offset, length, position) {\r\n          var contents = stream.node.contents;\r\n          if (position >= contents.length)\r\n            return 0;\r\n          var size = Math.min(contents.length - position, length);\r\n          assert(size >= 0);\r\n          if (contents.slice) { // normal array\r\n            for (var i = 0; i < size; i++) {\r\n              buffer[offset + i] = contents[position + i];\r\n            }\r\n          } else {\r\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\r\n              buffer[offset + i] = contents.get(position + i);\r\n            }\r\n          }\r\n          return size;\r\n        }\r\n        // use a custom read function\r\n        stream_ops.read = (stream, buffer, offset, length, position) => {\r\n          FS.forceLoadFile(node);\r\n          return writeChunks(stream, buffer, offset, length, position)\r\n        };\r\n        // use a custom mmap function\r\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\r\n          FS.forceLoadFile(node);\r\n          var ptr = mmapAlloc(length);\r\n          if (!ptr) {\r\n            throw new FS.ErrnoError(48);\r\n          }\r\n          writeChunks(stream, HEAP8, ptr, length, position);\r\n          return { ptr, allocated: true };\r\n        };\r\n        node.stream_ops = stream_ops;\r\n        return node;\r\n      },\r\n  absolutePath() {\r\n        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');\r\n      },\r\n  createFolder() {\r\n        abort('FS.createFolder has been removed; use FS.mkdir instead');\r\n      },\r\n  createLink() {\r\n        abort('FS.createLink has been removed; use FS.symlink instead');\r\n      },\r\n  joinPath() {\r\n        abort('FS.joinPath has been removed; use PATH.join instead');\r\n      },\r\n  mmapAlloc() {\r\n        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');\r\n      },\r\n  standardizePath() {\r\n        abort('FS.standardizePath has been removed; use PATH.normalize instead');\r\n      },\r\n  };\r\n  \r\n  var SYSCALLS = {\r\n  DEFAULT_POLLMASK:5,\r\n  calculateAt(dirfd, path, allowEmpty) {\r\n        if (PATH.isAbs(path)) {\r\n          return path;\r\n        }\r\n        // relative path\r\n        var dir;\r\n        if (dirfd === -100) {\r\n          dir = FS.cwd();\r\n        } else {\r\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\r\n          dir = dirstream.path;\r\n        }\r\n        if (path.length == 0) {\r\n          if (!allowEmpty) {\r\n            throw new FS.ErrnoError(44);;\r\n          }\r\n          return dir;\r\n        }\r\n        return dir + '/' + path;\r\n      },\r\n  writeStat(buf, stat) {\r\n        HEAP32[((buf)>>2)] = stat.dev;\r\n        HEAP32[(((buf)+(4))>>2)] = stat.mode;\r\n        HEAPU32[(((buf)+(8))>>2)] = stat.nlink;\r\n        HEAP32[(((buf)+(12))>>2)] = stat.uid;\r\n        HEAP32[(((buf)+(16))>>2)] = stat.gid;\r\n        HEAP32[(((buf)+(20))>>2)] = stat.rdev;\r\n        HEAP64[(((buf)+(24))>>3)] = BigInt(stat.size);\r\n        HEAP32[(((buf)+(32))>>2)] = 4096;\r\n        HEAP32[(((buf)+(36))>>2)] = stat.blocks;\r\n        var atime = stat.atime.getTime();\r\n        var mtime = stat.mtime.getTime();\r\n        var ctime = stat.ctime.getTime();\r\n        HEAP64[(((buf)+(40))>>3)] = BigInt(Math.floor(atime / 1000));\r\n        HEAPU32[(((buf)+(48))>>2)] = (atime % 1000) * 1000 * 1000;\r\n        HEAP64[(((buf)+(56))>>3)] = BigInt(Math.floor(mtime / 1000));\r\n        HEAPU32[(((buf)+(64))>>2)] = (mtime % 1000) * 1000 * 1000;\r\n        HEAP64[(((buf)+(72))>>3)] = BigInt(Math.floor(ctime / 1000));\r\n        HEAPU32[(((buf)+(80))>>2)] = (ctime % 1000) * 1000 * 1000;\r\n        HEAP64[(((buf)+(88))>>3)] = BigInt(stat.ino);\r\n        return 0;\r\n      },\r\n  writeStatFs(buf, stats) {\r\n        HEAP32[(((buf)+(4))>>2)] = stats.bsize;\r\n        HEAP32[(((buf)+(40))>>2)] = stats.bsize;\r\n        HEAP32[(((buf)+(8))>>2)] = stats.blocks;\r\n        HEAP32[(((buf)+(12))>>2)] = stats.bfree;\r\n        HEAP32[(((buf)+(16))>>2)] = stats.bavail;\r\n        HEAP32[(((buf)+(20))>>2)] = stats.files;\r\n        HEAP32[(((buf)+(24))>>2)] = stats.ffree;\r\n        HEAP32[(((buf)+(28))>>2)] = stats.fsid;\r\n        HEAP32[(((buf)+(44))>>2)] = stats.flags;  // ST_NOSUID\r\n        HEAP32[(((buf)+(36))>>2)] = stats.namelen;\r\n      },\r\n  doMsync(addr, stream, len, flags, offset) {\r\n        if (!FS.isFile(stream.node.mode)) {\r\n          throw new FS.ErrnoError(43);\r\n        }\r\n        if (flags & 2) {\r\n          // MAP_PRIVATE calls need not to be synced back to underlying fs\r\n          return 0;\r\n        }\r\n        var buffer = HEAPU8.slice(addr, addr + len);\r\n        FS.msync(stream, buffer, offset, len, flags);\r\n      },\r\n  getStreamFromFD(fd) {\r\n        var stream = FS.getStreamChecked(fd);\r\n        return stream;\r\n      },\r\n  varargs:undefined,\r\n  getStr(ptr) {\r\n        var ret = UTF8ToString(ptr);\r\n        return ret;\r\n      },\r\n  };\r\n  function _fd_close(fd) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      FS.close(stream);\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  /** @param {number=} offset */\r\n  var doReadv = (stream, iov, iovcnt, offset) => {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr;\r\n        if (curr < len) break; // nothing more to read\r\n        if (typeof offset != 'undefined') {\r\n          offset += curr;\r\n        }\r\n      }\r\n      return ret;\r\n    };\r\n  \r\n  function _fd_read(fd, iov, iovcnt, pnum) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      var num = doReadv(stream, iov, iovcnt);\r\n      HEAPU32[((pnum)>>2)] = num;\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  \r\n  var INT53_MAX = 9007199254740992;\r\n  \r\n  var INT53_MIN = -9007199254740992;\r\n  var bigintToI53Checked = (num) => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);\r\n  function _fd_seek(fd, offset, whence, newOffset) {\r\n    offset = bigintToI53Checked(offset);\r\n  \r\n    \r\n  try {\r\n  \r\n      if (isNaN(offset)) return 61;\r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      FS.llseek(stream, offset, whence);\r\n      HEAP64[((newOffset)>>3)] = BigInt(stream.position);\r\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n    return e.errno;\r\n  }\r\n  ;\r\n  }\r\n\r\n  /** @param {number=} offset */\r\n  var doWritev = (stream, iov, iovcnt, offset) => {\r\n      var ret = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\r\n        if (curr < 0) return -1;\r\n        ret += curr;\r\n        if (curr < len) {\r\n          // No more space to write.\r\n          break;\r\n        }\r\n        if (typeof offset != 'undefined') {\r\n          offset += curr;\r\n        }\r\n      }\r\n      return ret;\r\n    };\r\n  \r\n  function _fd_write(fd, iov, iovcnt, pnum) {\r\n  try {\r\n  \r\n      var stream = SYSCALLS.getStreamFromFD(fd);\r\n      var num = doWritev(stream, iov, iovcnt);\r\n      HEAPU32[((pnum)>>2)] = num;\r\n      return 0;\r\n    } catch (e) {\r\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\r\n    return e.errno;\r\n  }\r\n  }\r\n\r\n  \r\n  var runtimeKeepaliveCounter = 0;\r\n  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\r\n  var _proc_exit = (code) => {\r\n      EXITSTATUS = code;\r\n      if (!keepRuntimeAlive()) {\r\n        Module['onExit']?.(code);\r\n        ABORT = true;\r\n      }\r\n      quit_(code, new ExitStatus(code));\r\n    };\r\n  \r\n  \r\n  /** @param {boolean|number=} implicit */\r\n  var exitJS = (status, implicit) => {\r\n      EXITSTATUS = status;\r\n  \r\n      checkUnflushedContent();\r\n  \r\n      // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down\r\n      if (keepRuntimeAlive() && !implicit) {\r\n        var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;\r\n        err(msg);\r\n      }\r\n  \r\n      _proc_exit(status);\r\n    };\r\n\r\n  var handleException = (e) => {\r\n      // Certain exception types we do not treat as errors since they are used for\r\n      // internal control flow.\r\n      // 1. ExitStatus, which is thrown by exit()\r\n      // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\r\n      //    that wish to return to JS event loop.\r\n      if (e instanceof ExitStatus || e == 'unwind') {\r\n        return EXITSTATUS;\r\n      }\r\n      checkStackCookie();\r\n      if (e instanceof WebAssembly.RuntimeError) {\r\n        if (_emscripten_stack_get_current() <= 0) {\r\n          err('Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)');\r\n        }\r\n      }\r\n      quit_(1, e);\r\n    };\r\n\r\n  FS.createPreloadedFile = FS_createPreloadedFile;\r\n  FS.staticInit();\r\n  // Set module methods based on EXPORTED_RUNTIME_METHODS\r\n  ;\r\nfunction checkIncomingModuleAPI() {\r\n  ignoredModuleProp('fetchSettings');\r\n}\r\nvar wasmImports = {\r\n  /** @export */\r\n  _abort_js: __abort_js,\r\n  /** @export */\r\n  _tzset_js: __tzset_js,\r\n  /** @export */\r\n  emscripten_resize_heap: _emscripten_resize_heap,\r\n  /** @export */\r\n  environ_get: _environ_get,\r\n  /** @export */\r\n  environ_sizes_get: _environ_sizes_get,\r\n  /** @export */\r\n  fd_close: _fd_close,\r\n  /** @export */\r\n  fd_read: _fd_read,\r\n  /** @export */\r\n  fd_seek: _fd_seek,\r\n  /** @export */\r\n  fd_write: _fd_write\r\n};\r\nvar wasmExports;\r\ncreateWasm();\r\nvar ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors', 0);\r\nvar _main = Module['_main'] = createExportWrapper('main', 2);\r\nvar _fflush = createExportWrapper('fflush', 1);\r\nvar _strerror = createExportWrapper('strerror', 1);\r\nvar _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();\r\nvar _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'])();\r\nvar _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'])();\r\nvar _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();\r\nvar __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);\r\nvar __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\r\nvar _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();\r\n\r\n\r\n// include: postamble.js\r\n// === Auto-generated postamble setup entry stuff ===\r\n\r\nvar missingLibrarySymbols = [\r\n  'writeI53ToI64',\r\n  'writeI53ToI64Clamped',\r\n  'writeI53ToI64Signaling',\r\n  'writeI53ToU64Clamped',\r\n  'writeI53ToU64Signaling',\r\n  'readI53FromI64',\r\n  'readI53FromU64',\r\n  'convertI32PairToI53',\r\n  'convertI32PairToI53Checked',\r\n  'convertU32PairToI53',\r\n  'stackAlloc',\r\n  'getTempRet0',\r\n  'setTempRet0',\r\n  'growMemory',\r\n  'inetPton4',\r\n  'inetNtop4',\r\n  'inetPton6',\r\n  'inetNtop6',\r\n  'readSockaddr',\r\n  'writeSockaddr',\r\n  'emscriptenLog',\r\n  'readEmAsmArgs',\r\n  'jstoi_q',\r\n  'listenOnce',\r\n  'autoResumeAudioContext',\r\n  'getDynCaller',\r\n  'dynCall',\r\n  'runtimeKeepalivePush',\r\n  'runtimeKeepalivePop',\r\n  'callUserCallback',\r\n  'maybeExit',\r\n  'asmjsMangle',\r\n  'HandleAllocator',\r\n  'getNativeTypeSize',\r\n  'STACK_SIZE',\r\n  'STACK_ALIGN',\r\n  'POINTER_SIZE',\r\n  'ASSERTIONS',\r\n  'getCFunc',\r\n  'ccall',\r\n  'cwrap',\r\n  'uleb128Encode',\r\n  'sigToWasmTypes',\r\n  'generateFuncType',\r\n  'convertJsFunctionToWasm',\r\n  'getEmptyTableSlot',\r\n  'updateTableMap',\r\n  'getFunctionAddress',\r\n  'addFunction',\r\n  'removeFunction',\r\n  'reallyNegative',\r\n  'unSign',\r\n  'strLen',\r\n  'reSign',\r\n  'formatString',\r\n  'intArrayToString',\r\n  'AsciiToString',\r\n  'UTF16ToString',\r\n  'stringToUTF16',\r\n  'lengthBytesUTF16',\r\n  'UTF32ToString',\r\n  'stringToUTF32',\r\n  'lengthBytesUTF32',\r\n  'stringToNewUTF8',\r\n  'stringToUTF8OnStack',\r\n  'writeArrayToMemory',\r\n  'registerKeyEventCallback',\r\n  'maybeCStringToJsString',\r\n  'findEventTarget',\r\n  'getBoundingClientRect',\r\n  'fillMouseEventData',\r\n  'registerMouseEventCallback',\r\n  'registerWheelEventCallback',\r\n  'registerUiEventCallback',\r\n  'registerFocusEventCallback',\r\n  'fillDeviceOrientationEventData',\r\n  'registerDeviceOrientationEventCallback',\r\n  'fillDeviceMotionEventData',\r\n  'registerDeviceMotionEventCallback',\r\n  'screenOrientation',\r\n  'fillOrientationChangeEventData',\r\n  'registerOrientationChangeEventCallback',\r\n  'fillFullscreenChangeEventData',\r\n  'registerFullscreenChangeEventCallback',\r\n  'JSEvents_requestFullscreen',\r\n  'JSEvents_resizeCanvasForFullscreen',\r\n  'registerRestoreOldStyle',\r\n  'hideEverythingExceptGivenElement',\r\n  'restoreHiddenElements',\r\n  'setLetterbox',\r\n  'softFullscreenResizeWebGLRenderTarget',\r\n  'doRequestFullscreen',\r\n  'fillPointerlockChangeEventData',\r\n  'registerPointerlockChangeEventCallback',\r\n  'registerPointerlockErrorEventCallback',\r\n  'requestPointerLock',\r\n  'fillVisibilityChangeEventData',\r\n  'registerVisibilityChangeEventCallback',\r\n  'registerTouchEventCallback',\r\n  'fillGamepadEventData',\r\n  'registerGamepadEventCallback',\r\n  'registerBeforeUnloadEventCallback',\r\n  'fillBatteryEventData',\r\n  'battery',\r\n  'registerBatteryEventCallback',\r\n  'setCanvasElementSize',\r\n  'getCanvasElementSize',\r\n  'jsStackTrace',\r\n  'getCallstack',\r\n  'convertPCtoSourceLocation',\r\n  'checkWasiClock',\r\n  'wasiRightsToMuslOFlags',\r\n  'wasiOFlagsToMuslOFlags',\r\n  'safeSetTimeout',\r\n  'setImmediateWrapped',\r\n  'safeRequestAnimationFrame',\r\n  'clearImmediateWrapped',\r\n  'registerPostMainLoop',\r\n  'registerPreMainLoop',\r\n  'getPromise',\r\n  'makePromise',\r\n  'idsToPromises',\r\n  'makePromiseCallback',\r\n  'ExceptionInfo',\r\n  'findMatchingCatch',\r\n  'Browser_asyncPrepareDataCounter',\r\n  'isLeapYear',\r\n  'ydayFromDate',\r\n  'arraySum',\r\n  'addDays',\r\n  'getSocketFromFD',\r\n  'getSocketAddress',\r\n  'FS_unlink',\r\n  'FS_mkdirTree',\r\n  '_setNetworkCallback',\r\n  'heapObjectForWebGLType',\r\n  'toTypedArrayIndex',\r\n  'webgl_enable_ANGLE_instanced_arrays',\r\n  'webgl_enable_OES_vertex_array_object',\r\n  'webgl_enable_WEBGL_draw_buffers',\r\n  'webgl_enable_WEBGL_multi_draw',\r\n  'webgl_enable_EXT_polygon_offset_clamp',\r\n  'webgl_enable_EXT_clip_control',\r\n  'webgl_enable_WEBGL_polygon_mode',\r\n  'emscriptenWebGLGet',\r\n  'computeUnpackAlignedImageSize',\r\n  'colorChannelsInGlTextureFormat',\r\n  'emscriptenWebGLGetTexPixelData',\r\n  'emscriptenWebGLGetUniform',\r\n  'webglGetUniformLocation',\r\n  'webglPrepareUniformLocationsBeforeFirstUse',\r\n  'webglGetLeftBracePos',\r\n  'emscriptenWebGLGetVertexAttrib',\r\n  '__glGetActiveAttribOrUniform',\r\n  'writeGLArray',\r\n  'registerWebGlEventCallback',\r\n  'runAndAbortIfError',\r\n  'ALLOC_NORMAL',\r\n  'ALLOC_STACK',\r\n  'allocate',\r\n  'writeStringToMemory',\r\n  'writeAsciiToMemory',\r\n  'setErrNo',\r\n  'demangle',\r\n  'stackTrace',\r\n];\r\nmissingLibrarySymbols.forEach(missingLibrarySymbol)\r\n\r\nvar unexportedSymbols = [\r\n  'run',\r\n  'addOnPreRun',\r\n  'addOnInit',\r\n  'addOnPreMain',\r\n  'addOnExit',\r\n  'addOnPostRun',\r\n  'addRunDependency',\r\n  'removeRunDependency',\r\n  'out',\r\n  'err',\r\n  'callMain',\r\n  'abort',\r\n  'wasmMemory',\r\n  'wasmExports',\r\n  'writeStackCookie',\r\n  'checkStackCookie',\r\n  'INT53_MAX',\r\n  'INT53_MIN',\r\n  'bigintToI53Checked',\r\n  'stackSave',\r\n  'stackRestore',\r\n  'ptrToString',\r\n  'zeroMemory',\r\n  'exitJS',\r\n  'getHeapMax',\r\n  'abortOnCannotGrowMemory',\r\n  'ENV',\r\n  'ERRNO_CODES',\r\n  'strError',\r\n  'DNS',\r\n  'Protocols',\r\n  'Sockets',\r\n  'timers',\r\n  'warnOnce',\r\n  'readEmAsmArgsArray',\r\n  'jstoi_s',\r\n  'getExecutableName',\r\n  'handleException',\r\n  'keepRuntimeAlive',\r\n  'asyncLoad',\r\n  'alignMemory',\r\n  'mmapAlloc',\r\n  'wasmTable',\r\n  'noExitRuntime',\r\n  'freeTableIndexes',\r\n  'functionsInTableMap',\r\n  'setValue',\r\n  'getValue',\r\n  'PATH',\r\n  'PATH_FS',\r\n  'UTF8Decoder',\r\n  'UTF8ArrayToString',\r\n  'UTF8ToString',\r\n  'stringToUTF8Array',\r\n  'stringToUTF8',\r\n  'lengthBytesUTF8',\r\n  'intArrayFromString',\r\n  'stringToAscii',\r\n  'UTF16Decoder',\r\n  'JSEvents',\r\n  'specialHTMLTargets',\r\n  'findCanvasEventTarget',\r\n  'currentFullscreenStrategy',\r\n  'restoreOldWindowedStyle',\r\n  'UNWIND_CACHE',\r\n  'ExitStatus',\r\n  'getEnvStrings',\r\n  'doReadv',\r\n  'doWritev',\r\n  'initRandomFill',\r\n  'randomFill',\r\n  'emSetImmediate',\r\n  'emClearImmediate_deps',\r\n  'emClearImmediate',\r\n  'promiseMap',\r\n  'uncaughtExceptionCount',\r\n  'exceptionLast',\r\n  'exceptionCaught',\r\n  'Browser',\r\n  'getPreloadedImageData__data',\r\n  'wget',\r\n  'MONTH_DAYS_REGULAR',\r\n  'MONTH_DAYS_LEAP',\r\n  'MONTH_DAYS_REGULAR_CUMULATIVE',\r\n  'MONTH_DAYS_LEAP_CUMULATIVE',\r\n  'SYSCALLS',\r\n  'preloadPlugins',\r\n  'FS_createPreloadedFile',\r\n  'FS_modeStringToFlags',\r\n  'FS_getMode',\r\n  'FS_stdin_getChar_buffer',\r\n  'FS_stdin_getChar',\r\n  'FS_createPath',\r\n  'FS_createDevice',\r\n  'FS_readFile',\r\n  'FS',\r\n  'FS_createDataFile',\r\n  'FS_createLazyFile',\r\n  'MEMFS',\r\n  'TTY',\r\n  'PIPEFS',\r\n  'SOCKFS',\r\n  'tempFixedLengthArray',\r\n  'miniTempWebGLFloatBuffers',\r\n  'miniTempWebGLIntBuffers',\r\n  'GL',\r\n  'AL',\r\n  'GLUT',\r\n  'EGL',\r\n  'GLEW',\r\n  'IDBStore',\r\n  'SDL',\r\n  'SDL_gfx',\r\n  'allocateUTF8',\r\n  'allocateUTF8OnStack',\r\n  'print',\r\n  'printErr',\r\n];\r\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\r\n\r\n\r\n\r\nvar calledRun;\r\n\r\nfunction callMain() {\r\n  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\r\n  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');\r\n\r\n  var entryFunction = _main;\r\n\r\n  var argc = 0;\r\n  var argv = 0;\r\n\r\n  try {\r\n\r\n    var ret = entryFunction(argc, argv);\r\n\r\n    // if we're not running an evented main loop, it's time to exit\r\n    exitJS(ret, /* implicit = */ true);\r\n    return ret;\r\n  } catch (e) {\r\n    return handleException(e);\r\n  }\r\n}\r\n\r\nfunction stackCheckInit() {\r\n  // This is normally called automatically during __wasm_call_ctors but need to\r\n  // get these values before even running any of the ctors so we call it redundantly\r\n  // here.\r\n  _emscripten_stack_init();\r\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\r\n  writeStackCookie();\r\n}\r\n\r\nfunction run() {\r\n\r\n  if (runDependencies > 0) {\r\n    dependenciesFulfilled = run;\r\n    return;\r\n  }\r\n\r\n  stackCheckInit();\r\n\r\n  preRun();\r\n\r\n  // a preRun added a dependency, run will be called later\r\n  if (runDependencies > 0) {\r\n    dependenciesFulfilled = run;\r\n    return;\r\n  }\r\n\r\n  function doRun() {\r\n    // run may have just been called through dependencies being fulfilled just in this very frame,\r\n    // or while the async setStatus time below was happening\r\n    assert(!calledRun);\r\n    calledRun = true;\r\n    Module['calledRun'] = true;\r\n\r\n    if (ABORT) return;\r\n\r\n    initRuntime();\r\n\r\n    preMain();\r\n\r\n    Module['onRuntimeInitialized']?.();\r\n\r\n    var noInitialRun = Module['noInitialRun'];legacyModuleProp('noInitialRun', 'noInitialRun');\r\n    if (!noInitialRun) callMain();\r\n\r\n    postRun();\r\n  }\r\n\r\n  if (Module['setStatus']) {\r\n    Module['setStatus']('Running...');\r\n    setTimeout(() => {\r\n      setTimeout(() => Module['setStatus'](''), 1);\r\n      doRun();\r\n    }, 1);\r\n  } else\r\n  {\r\n    doRun();\r\n  }\r\n  checkStackCookie();\r\n}\r\n\r\nfunction checkUnflushedContent() {\r\n  // Compiler settings do not allow exiting the runtime, so flushing\r\n  // the streams is not possible. but in ASSERTIONS mode we check\r\n  // if there was something to flush, and if so tell the user they\r\n  // should request that the runtime be exitable.\r\n  // Normally we would not even include flush() at all, but in ASSERTIONS\r\n  // builds we do so just for this check, and here we see if there is any\r\n  // content to flush, that is, we check if there would have been\r\n  // something a non-ASSERTIONS build would have not seen.\r\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\r\n  // mode (which has its own special function for this; otherwise, all\r\n  // the code is inside libc)\r\n  var oldOut = out;\r\n  var oldErr = err;\r\n  var has = false;\r\n  out = err = (x) => {\r\n    has = true;\r\n  }\r\n  try { // it doesn't matter if it fails\r\n    _fflush(0);\r\n    // also flush in the JS FS layer\r\n    ['stdout', 'stderr'].forEach((name) => {\r\n      var info = FS.analyzePath('/dev/' + name);\r\n      if (!info) return;\r\n      var stream = info.object;\r\n      var rdev = stream.rdev;\r\n      var tty = TTY.ttys[rdev];\r\n      if (tty?.output?.length) {\r\n        has = true;\r\n      }\r\n    });\r\n  } catch(e) {}\r\n  out = oldOut;\r\n  err = oldErr;\r\n  if (has) {\r\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\r\n  }\r\n}\r\n\r\nif (Module['preInit']) {\r\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\r\n  while (Module['preInit'].length > 0) {\r\n    Module['preInit'].pop()();\r\n  }\r\n}\r\n\r\nrun();\r\n\r\n// end include: postamble.js\r\n\r\n\n\n//# sourceURL=webpack://GloryGameEngine/./out/engine.out.js?");

/***/ }),

/***/ "?b10a":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://GloryGameEngine/crypto_(ignored)?");

/***/ }),

/***/ "?44c4":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://GloryGameEngine/fs_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./out/engine.out.js");
/******/ 	GloryGameEngine = __webpack_exports__;
/******/ 	
/******/ })()
;